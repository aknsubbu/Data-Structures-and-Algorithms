<!DOCTYPE html>
<html>

<head>
    <title>leetcode.md</title>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    
<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

html,footer,header{
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Custom MD PDF CSS
 */
html,footer,header{
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";

 }
body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>
<link rel="stylesheet" href="file:///home/kishore/Data-Structures-and-Algorithms/R%3A%5C2.Travail%5C1.Enseignement%5CCours%5C_1.Outils%5C2.Developpement%5C1.SCSS%5Cmain.css" type="text/css"><link rel="stylesheet" href="file:///home/kishore/Data-Structures-and-Algorithms/D%3A%5Crdaros%5CCours%5C_1.Outils%5C2.Developpement%5C1.SCSS%5Cmain.css" type="text/css">
</head>

<body>
    <h6 id="22---09---2023---psg-college-of-technology">22 - 09 - 2023   - PSG College of Technology</h6>
<hr>
<h1 id="19z310---data-structures-laboratory">19z310 - Data Structures Laboratory</h1>
<h2 id="leetcode-questions-solved">Leetcode questions solved</h2>
<h4 id="kishoreadhith-v">Kishoreadhith V</h4>
<h4 id="22z232">22z232</h4>
<h4 id="be-cse-g1">BE CSE G1</h4>
<hr>
<h2 id="table-of-contents">Table of Contents</h2>
<table>
<thead>
<tr>
<th>No.</th>
<th>Problem</th>
<th>Difficulty</th>
<th>Concept</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Find the Highest Altitude - 1732</td>
<td>Easy</td>
<td>Arrays</td>
</tr>
<tr>
<td>2</td>
<td>Cells with Odd Values in a Matrix - 1252</td>
<td>Easy</td>
<td>Arrays</td>
</tr>
<tr>
<td>3</td>
<td>Matrix Diagonal Sum - 1572</td>
<td>Easy</td>
<td>Arrays</td>
</tr>
<tr>
<td>4</td>
<td>Convert Binary Number in a Linked List - 1290</td>
<td>Easy</td>
<td>Linked Lists</td>
</tr>
<tr>
<td>5</td>
<td>Merge Two Sorted Lists - 21</td>
<td>Easy</td>
<td>Linked Lists</td>
</tr>
<tr>
<td>6</td>
<td>Linked List Cycle - 141</td>
<td>Easy</td>
<td>Linked Lists</td>
</tr>
<tr>
<td>7</td>
<td>Set Matrix Zeros - 73</td>
<td>Medium</td>
<td>Arrays</td>
</tr>
<tr>
<td>8</td>
<td>House Robber - 198</td>
<td>Medium</td>
<td>Arrays</td>
</tr>
<tr>
<td>9</td>
<td>Spiral Matrix - 54</td>
<td>Medium</td>
<td>Arrays</td>
</tr>
<tr>
<td>10</td>
<td>Add Two Numbers - 2</td>
<td>Medium</td>
<td>Linked Lists</td>
</tr>
<tr>
<td>11</td>
<td>Remove Nth Node From End of List - 19</td>
<td>Medium</td>
<td>Linked Lists</td>
</tr>
<tr>
<td>12</td>
<td>Linked List Cycle 2 - 142</td>
<td>Medium</td>
<td>Linked Lists</td>
</tr>
<tr>
<td>13</td>
<td>Delete the Middle Node of a Linked List - 2095</td>
<td>Medium</td>
<td>Linked Lists</td>
</tr>
<tr>
<td>14</td>
<td>Median of Two Sorted Arrays - 4</td>
<td>Hard</td>
<td>Arrays</td>
</tr>
<tr>
<td>15</td>
<td>Reverse Nodes in k-Group - 25</td>
<td>Hard</td>
<td>Linked Lists</td>
</tr>
</tbody>
</table>
<p>Total Questions solved: 33</p>
<ul>
<li>easy - 24</li>
<li>medium - 7</li>
<li>hard - 2</li>
</ul>
<hr>
<h2 id="1-find-the-highest-altitude---1732--easy">1. Find the Highest Altitude - 1732 | <code>Easy</code></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.</p>
<p>You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i​​​​​​ and i + 1 for all (0 &lt;= i &lt; n). Return the highest altitude of a point.</p>
<h3 id="solution">Solution</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestAltitude</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] gain)</span> </span>{
        <span class="hljs-keyword">int</span>[] alt = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[gain.length + <span class="hljs-number">1</span>];
        alt[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; alt.length; i++){
            alt[i] = alt[i-<span class="hljs-number">1</span>] + gain[i-<span class="hljs-number">1</span>];
            <span class="hljs-keyword">if</span>(alt[i] &gt; max){
                max = alt[i];
            }
        } 
        <span class="hljs-keyword">return</span> max;
    }
}
</div></code></pre>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(n)</li>
</ul>
<h3 id="runtime-stats">Runtime Stats</h3>
<ul>
<li>Runtime: <code>0 ms</code>, faster than <code>100.00%</code> of Java online submissions for Find the Highest Altitude.</li>
<li>Memory Usage: <code>41.2 MB</code>, less than <code>6.57%</code> of Java online submissions for Find the Highest Altitude.</li>
</ul>
<hr>
<h2 id="2-cells-with-odd-values-in-a-matrix---1252--easy">2. Cells with Odd Values in a Matrix - 1252 | <code>Easy</code></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>There is an m x n matrix that is initialized to all 0's. There is also a 2D array indices where each indices[i] = [ri, ci] represents a 0-indexed location to perform some increment operations on the matrix.</p>
<p>For each location indices[i], do both of the following:</p>
<p>Increment all the cells on row ri.<br>
Increment all the cells on column ci.<br>
Given m, n, and indices, return the number of odd-valued cells in the matrix after applying the increment to all locations in indices.</p>
<h3 id="solution">Solution</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">oddCells</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span>[][] indices)</span> </span>{
        <span class="hljs-keyword">int</span>[][] matrix = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] index: indices){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>; c &lt; n; c++){
                matrix[index[<span class="hljs-number">0</span>]][c]++;
            }
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; m; r++){
                matrix[r][index[<span class="hljs-number">1</span>]]++;
            }
        }
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span>[] row: matrix){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> col: row){
                <span class="hljs-keyword">if</span>(col % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>){
                    count++;
                }
            }
        }
        <span class="hljs-keyword">return</span> count;
    }
}
</div></code></pre>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>Time Complexity: O(indices.length * (mn))</li>
<li>Space Complexity: O(mn)</li>
</ul>
<h3 id="runtime-stats">Runtime Stats</h3>
<ul>
<li>Runtime: <code>2 ms</code>, faster than <code>64.40%</code> of Java online submissions for Cells with Odd Values in a Matrix.</li>
<li>Memory Usage: <code>40.8 MB</code>, less than <code>19.49%</code> of Java online submissions for Cells with Odd Values in a Matrix.</li>
</ul>
<hr>
<h2 id="3-matrix-diagonal-sum---1572--easy">3. Matrix Diagonal Sum - 1572 | <code>Easy</code></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given a square matrix mat, return the sum of the matrix diagonals.</p>
<p>Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.</p>
<h3 id="solution">Solution</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">diagonalSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] mat)</span> </span>{
        <span class="hljs-keyword">int</span> size = mat.length - <span class="hljs-number">1</span>;
        <span class="hljs-comment">// here size refers to max index</span>
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= size; i++){
            sum += mat[i][i];
            sum += mat[i][size - i];
        }
        <span class="hljs-comment">// mid element is subtracted from even size as size here is max index hence odd size</span>
        <span class="hljs-keyword">if</span>(size %<span class="hljs-number">2</span> == <span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> sum - mat [size / <span class="hljs-number">2</span>][size / <span class="hljs-number">2</span>];
        }
        <span class="hljs-keyword">return</span> sum;
    }
}
</div></code></pre>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(1)</li>
</ul>
<h3 id="runtime-stats">Runtime Stats</h3>
<ul>
<li>Runtime: <code>0 ms</code>, faster than <code>100.00%</code> of Java online submissions for Matrix Diagonal Sum.</li>
<li>Memory Usage: <code>43.6 MB</code>, less than <code>77.92%</code> of Java online submissions for Matrix Diagonal Sum.</li>
</ul>
<hr>
<h2 id="4-convert-binary-number-in-a-linked-list---1290--easy">4. Convert Binary Number in a Linked List - 1290 | <code>Easy</code></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.</p>
<p>Return the decimal value of the number in the linked list.</p>
<p>The most significant bit is at the head of the linked list.</p>
<h3 id="solution">Solution</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDecimalValue</span><span class="hljs-params">(ListNode head)</span> </span>{
        ListNode temp = head;
        <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span>){
            temp = temp.next;
            size++;
        }
        System.out.print(size);
        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
        temp = head;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = size-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){
            res += (temp.val * Math.pow(<span class="hljs-number">2</span>, i));
            temp = temp.next;
        }
        <span class="hljs-keyword">return</span> res;
    }
}
</div></code></pre>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>Time Complexity: O(n^2)</li>
<li>Space Complexity: O(1)</li>
</ul>
<h3 id="runtime-stats">Runtime Stats</h3>
<ul>
<li>Runtime: <code>1 ms</code>, faster than <code>20.85%</code> of Java online submissions for Convert Binary Number in a Linked List.</li>
<li>Memory Usage: <code>39.9 MB</code>, less than <code>52.66%</code> of Java online submissions for Convert Binary Number in a Linked List.</li>
</ul>
<hr>
<h2 id="5-merge-two-sorted-lists---21--easy">5. Merge Two Sorted Lists - 21 | <code>Easy</code></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>You are given the heads of two sorted linked lists list1 and list2.</p>
<p>Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.</p>
<p>Return the head of the merged linked list.</p>
<h3 id="solution">Solution</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> </span>{
        ListNode current = <span class="hljs-keyword">new</span> ListNode();
        ListNode head = current;

        <span class="hljs-keyword">while</span>(list1 != <span class="hljs-keyword">null</span> &amp;&amp; list2 != <span class="hljs-keyword">null</span>){
            <span class="hljs-keyword">if</span>(list1.val &lt; list2.val){
                current.next = list1;
                list1 = list1.next;
                current = current.next;
            } <span class="hljs-keyword">else</span> {
                current.next = list2;
                list2 = list2.next;
                current = current.next;
            }
        }

        <span class="hljs-keyword">if</span>(list1 != <span class="hljs-keyword">null</span>){
            current.next = list1;
        } <span class="hljs-keyword">else</span> {
            current.next = list2;
        }
        <span class="hljs-keyword">return</span> head.next;
    }    
}
</div></code></pre>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(1)</li>
</ul>
<h3 id="runtime-stats">Runtime Stats</h3>
<ul>
<li>Runtime: <code>0 ms</code>, faster than <code>100.00%</code> of Java online submissions for Merge Two Sorted Lists.</li>
<li>Memory Usage: <code>41.3 MB</code>, less than <code>60.7%</code> of Java online submissions for Merge Two Sorted Lists.</li>
</ul>
<hr>
<h2 id="6-linked-list-cycle---141--easy">6. Linked List Cycle - 141 | <code>Easy</code></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given head, the head of a linked list, determine if the linked list has a cycle in it.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.</p>
<p>Return true if there is a cycle in the linked list. Otherwise, return false.</p>
<h3 id="solution">Solution</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>{
        ListNode slow = head;
        ListNode fast = head;
        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>){
            slow = slow.next;
            fast = fast.next.next;
            <span class="hljs-keyword">if</span>(slow == fast){
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    }
}
</div></code></pre>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(1)</li>
</ul>
<h3 id="runtime-stats">Runtime Stats</h3>
<ul>
<li>Runtime: <code>0 ms</code>, faster than <code>100.00%</code> of Java online submissions for Linked List Cycle.</li>
<li>Memory Usage: <code>43.4 MB</code>, less than <code>59.93%</code> of Java online submissions for Linked List Cycle.</li>
</ul>
<hr>
<h2 id="7-set-matrix-zeros---73--medium">7. Set Matrix Zeros - 73 | <code>Medium</code></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.</p>
<p>You must do it in place.</p>
<h3 id="solution">Solution</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>{
        <span class="hljs-keyword">int</span> m = matrix.length;
        <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].length;
        <span class="hljs-keyword">int</span>[] zero_rows = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];
        <span class="hljs-keyword">int</span>[] zero_cols = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];
        Arrays.fill(zero_rows, <span class="hljs-number">0</span>);
        Arrays.fill(zero_cols, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++){
                <span class="hljs-keyword">if</span>(matrix[i][j] == <span class="hljs-number">0</span>){
                    <span class="hljs-keyword">if</span>(zero_rows[i] == <span class="hljs-number">0</span>){
                        zero_rows[i] = <span class="hljs-number">1</span>;
                    }
                    <span class="hljs-keyword">if</span>(zero_cols[j] == <span class="hljs-number">0</span>){
                        zero_cols[j] = <span class="hljs-number">1</span>;
                    }
                }
            }
        }
        System.out.println(Arrays.toString(zero_rows));
        System.out.println(Arrays.toString(zero_cols));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++){
            <span class="hljs-keyword">if</span>(zero_rows[i] == <span class="hljs-number">1</span>){
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++){
                    matrix[i][j] = <span class="hljs-number">0</span>;
                }
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++){
                    <span class="hljs-keyword">if</span>(zero_cols[j] == <span class="hljs-number">1</span>){
                        matrix[i][j] = <span class="hljs-number">0</span>;
                    }
                }
            }
        }
    }
}
</div></code></pre>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>Time Complexity: O(mn)</li>
<li>Space Complexity: O(m+n)</li>
</ul>
<h3 id="runtime-stats">Runtime Stats</h3>
<ul>
<li>Runtime: <code>4 ms</code>, faster than <code>7.34%</code> of Java online submissions for Set Matrix Zeroes.</li>
<li>Memory Usage: <code>44.6 MB</code>, less than <code>58.23%</code> of Java online submissions for Set Matrix Zeroes.</li>
</ul>
<hr>
<h2 id="8-house-robber---198--medium">8. House Robber - 198 | <code>Medium</code></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</p>
<p>Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.</p>
<h3 id="solution">Solution</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isLootable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h1, <span class="hljs-keyword">int</span> h2)</span></span>{
    <span class="hljs-keyword">return</span> ((h1 - h2 == <span class="hljs-number">1</span>)||(h2 - h1 == <span class="hljs-number">1</span>)) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* nums, <span class="hljs-keyword">int</span> numsSize)</span></span>{
    <span class="hljs-keyword">int</span> loot[numsSize];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize; i++){
        loot[i] = nums[i];
        <span class="hljs-keyword">int</span> lootablesSize = i &gt; <span class="hljs-number">1</span> ? i-<span class="hljs-number">1</span> : <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> lootablesArray[lootablesSize];
        <span class="hljs-keyword">int</span> lootables = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i-<span class="hljs-number">1</span>; j++){
            <span class="hljs-keyword">if</span>(isLootable(j,i)){
                lootablesArray[lootables] = j;
                lootables++;
            }
        }
        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>; k &lt; lootables; k++){
            <span class="hljs-keyword">if</span>(loot[lootablesArray[k]] &gt; max){
                max = loot[lootablesArray[k]];
            }
        }
        loot[i] = nums[i] + max;
    }

    <span class="hljs-keyword">int</span> maxLoot=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize; i++){
        <span class="hljs-keyword">if</span>(loot[i] &gt; maxLoot){
            maxLoot = loot[i];
        }
    }
    <span class="hljs-keyword">return</span> maxLoot;
}
</div></code></pre>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>Time Complexity: O(n^2)</li>
<li>Space Complexity: O(n)</li>
</ul>
<h3 id="runtime-stats">Runtime Stats</h3>
<ul>
<li>Runtime: <code>3 ms</code>, faster than <code>45.74%</code> of C online submissions for House Robber.</li>
<li>Memory Usage: <code>5.6 MB</code>, less than <code>90.70%</code> of C online submissions for House Robber.</li>
</ul>
<hr>
<h2 id="9-spiral-matrix---54--medium">9. Spiral Matrix - 54 | <code>Medium</code></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given an m x n matrix, return all elements of the matrix in spiral order.</p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="Alt text"></p>
<h3 id="solution">Solution</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">spiralOrder</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>{
        <span class="hljs-keyword">int</span> rows = matrix.length;
        <span class="hljs-keyword">int</span> cols = matrix[<span class="hljs-number">0</span>].length;
        <span class="hljs-keyword">int</span> res_len = rows * cols;
        <span class="hljs-keyword">int</span> rotationsLimit = rows &gt; cols ? (rows/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span> : (cols/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;
        List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>; r &lt; rotationsLimit; r++){
            j = r;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j1 = j ; j1 &lt; cols - r; j1++){
                j = j1;
                res.add(matrix[i][j]);
            }
            <span class="hljs-keyword">if</span>(res.size() == res_len){
                <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i1 = i + <span class="hljs-number">1</span>; i1 &lt; rows - r; i1++){
                i = i1;
                res.add(matrix[i][j]);
            }
            <span class="hljs-keyword">if</span>(res.size() == res_len){
                <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j1 = j - <span class="hljs-number">1</span>; j1 &gt;= r; j1--){
                j = j1;
                res.add(matrix[i][j]);
            }
            <span class="hljs-keyword">if</span>(res.size() == res_len){
                <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i1 = i - <span class="hljs-number">1</span>; i1 &gt; r; i1--){
                i = i1;
                res.add(matrix[i][j]);
            }
        }
        <span class="hljs-keyword">return</span> res;
        }
    }
</div></code></pre>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>Time Complexity: O(n^2)</li>
<li>Space Complexity: O(n)</li>
</ul>
<h3 id="runtime-stats">Runtime Stats</h3>
<ul>
<li>Runtime: <code>0 ms</code>, faster than <code>100.00%</code> of Java online submissions for Spiral Matrix.</li>
<li>Memory Usage: <code>40.7 MB</code>, less than <code>35.76%</code> of Java online submissions for Spiral Matrix.</li>
</ul>
<hr>
<h2 id="10-add-two-numbers---2--medium">10. Add Two Numbers - 2  | <code>Medium</code></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<h3 id="solution">Solution</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>{
        ListNode current = <span class="hljs-keyword">new</span> ListNode();
        ListNode res = current;
        <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;
        <span class="hljs-comment">// adding digits when both lists have digits</span>
        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span> &amp;&amp; l2 != <span class="hljs-keyword">null</span>){
            <span class="hljs-keyword">int</span> dig = l1.val + l2.val + carry;
            carry = dig / <span class="hljs-number">10</span>;
            ListNode digit = <span class="hljs-keyword">new</span> ListNode(dig % <span class="hljs-number">10</span>);
            current.next = digit;
            l1 = l1.next;
            l2 = l2.next;
            current = current.next;
        }
        <span class="hljs-comment">// adding digits when l1 has digits</span>
        <span class="hljs-keyword">while</span>(l1 != <span class="hljs-keyword">null</span>){
            <span class="hljs-keyword">int</span> dig = l1.val + carry;
            carry = dig / <span class="hljs-number">10</span>;
            ListNode digit = <span class="hljs-keyword">new</span> ListNode(dig % <span class="hljs-number">10</span>);
            current.next = digit;
            l1 = l1.next;
            current = current.next;
        }
        <span class="hljs-comment">// adding digits when l2 has digits</span>
        <span class="hljs-keyword">while</span>(l2 != <span class="hljs-keyword">null</span>){
            <span class="hljs-keyword">int</span> dig = l2.val + carry;
            carry = dig / <span class="hljs-number">10</span>;
            ListNode digit = <span class="hljs-keyword">new</span> ListNode(dig % <span class="hljs-number">10</span>);
            current.next = digit;
            l2 = l2.next;
            current = current.next;
        }
        <span class="hljs-comment">// adding carry if any</span>
        <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>){
            ListNode digit = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">1</span>);
            current.next = digit;
        }
        <span class="hljs-keyword">return</span> res.next;
    }
}
</div></code></pre>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(n)<br>
where n is the length of the longer list</li>
</ul>
<h3 id="runtime-stats">Runtime Stats</h3>
<ul>
<li>Runtime: <code>1 ms</code>, faster than <code>100.00%</code> of Java online submissions for Add Two Numbers.</li>
<li>Memory Usage: <code>43 MB</code>, less than <code>83.18%</code> of Java online submissions for Add Two Numbers.</li>
</ul>
<hr>
<h2 id="11-remove-nth-node-from-end-of-list---19--medium">11. Remove Nth Node From End of List - 19 | <code>Medium</code></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given the head of a linked list, remove the nth node from the end of the list and return its head.</p>
<h3 id="solution">Solution</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>{
        ListNode temp = head;
        <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span>){
            size++;
            temp = temp.next;
        }  
        <span class="hljs-keyword">if</span>(size == <span class="hljs-number">1</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
        <span class="hljs-keyword">if</span>(size == n){
            <span class="hljs-keyword">return</span> head.next;
        }
        temp = head;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; size-n; i++){
            temp = temp.next;
        }
        System.out.print(temp.next.val);
        temp.next = (n == <span class="hljs-number">1</span>)? <span class="hljs-keyword">null</span> : temp.next.next;
        <span class="hljs-keyword">return</span> head;
    }
}
</div></code></pre>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(1)</li>
</ul>
<h3 id="runtime-stats">Runtime Stats</h3>
<ul>
<li>Runtime: <code>2 ms</code>, faster than <code>6.94%</code> of Java online submissions for Remove Nth Node From End of List.</li>
<li>Memory Usage: <code>40.2 MB</code>, less than <code>93.13%</code> of Java online submissions for Remove Nth Node From End of List.</li>
</ul>
<hr>
<h2 id="12-linked-list-cycle-2---142--medium">12. Linked List Cycle 2 - 142 | <code>Medium</code></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.</p>
<p>Do not modify the linked list.</p>
<h3 id="solution">Solution</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>{
                ListNode slow = head;
        ListNode fast = head;
        <span class="hljs-keyword">while</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>){
            slow = slow.next;
            fast = fast.next.next;
            
            <span class="hljs-keyword">if</span>(slow == fast){
                ListNode temp = slow;
                <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">do</span>{
                    temp = temp.next;
                    length++;
                } <span class="hljs-keyword">while</span>(temp != slow);
                <span class="hljs-comment">// now we have the length, so we start the two pointers.</span>
                ListNode first = head;
                ListNode second = head;
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++){
                    second = second.next;
                }
                <span class="hljs-keyword">while</span>(first != second){
                    first = first.next;
                    second = second.next;
                }
                <span class="hljs-keyword">return</span> first;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;

    }
}
</div></code></pre>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(1)</li>
</ul>
<h3 id="runtime-stats">Runtime Stats</h3>
<ul>
<li>Runtime: <code>0 ms</code>, faster than <code>100.00%</code> of Java online submissions for Linked List Cycle II.</li>
<li>Memory Usage: <code>43.9 MB</code>, less than <code>22.49%</code> of Java online submissions for Linked List Cycle II.</li>
</ul>
<hr>
<h2 id="13-delete-the-middle-node-of-a-linked-list---2095--medium">13. Delete the Middle Node of a Linked List - 2095 | <code>Medium</code></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.</p>
<p>The middle node of a linked list of size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x.</p>
<p>For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.</p>
<h3 id="solution">Solution</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">deleteMiddle</span><span class="hljs-params">(ListNode head)</span> </span>{
        ListNode temp = head;
        <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(temp != <span class="hljs-keyword">null</span>){
            size++;
            temp = temp.next;
        }
        <span class="hljs-keyword">if</span>(size == <span class="hljs-number">1</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
        ListNode prev = head;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i++){
            prev = prev.next;
        }
        <span class="hljs-comment">// System.out.print(prev.val);</span>
        prev.next = (prev.next == <span class="hljs-keyword">null</span>)? <span class="hljs-keyword">null</span> : prev.next.next;
        <span class="hljs-keyword">return</span> head;
    }
}
</div></code></pre>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(1)</li>
</ul>
<h3 id="runtime-stats">Runtime Stats</h3>
<ul>
<li>Runtime: <code>3 ms</code>, faster than <code>96.46%</code> of Java online submissions for Delete Middle of Linked List.</li>
<li>Memory Usage: <code>63 MB</code>, less than <code>98.28%</code> of Java online submissions for Delete Middle of Linked List.</li>
</ul>
<hr>
<h2 id="14-median-of-two-sorted-arrays---4--hard">14. Median of Two Sorted Arrays - 4 | <code>Hard</code></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.</p>
<p>The overall run time complexity should be O(log (m+n)).</p>
<h3 id="solution">Solution</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>{
        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums1.length + nums2.length];
        <span class="hljs-keyword">int</span> c1 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> c2 = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(c1 &lt; nums1.length &amp;&amp; c2 &lt; nums2.length){
            <span class="hljs-keyword">if</span>(nums1[c1] &lt; nums2[c2]){
                res[count] = nums1[c1];
                c1++;
            } <span class="hljs-keyword">else</span> {
                res[count] = nums2[c2];
                c2++;
            }
            count++;
        }
        <span class="hljs-keyword">if</span>(c1 &lt; nums1.length){
            <span class="hljs-keyword">while</span>(c1 &lt; nums1.length){
                res[count] = nums1[c1];
                c1++;
                count++;
            }
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">while</span>(c2 &lt; nums2.length){
                res[count] = nums2[c2];
                c2++;
                count++;
            }
        }
        <span class="hljs-keyword">double</span> median;
        System.out.print(Arrays.toString(res));
        <span class="hljs-keyword">if</span>(res.length % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>){
            median = ((<span class="hljs-keyword">double</span>)res[res.length/<span class="hljs-number">2</span>] + (<span class="hljs-keyword">double</span>)res[res.length/<span class="hljs-number">2</span> -<span class="hljs-number">1</span>])/<span class="hljs-number">2</span>;
            
        } <span class="hljs-keyword">else</span> {
            median = res[res.length/<span class="hljs-number">2</span>];
        }
        System.out.print(median);
        <span class="hljs-keyword">return</span> median;
    }
}
</div></code></pre>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>Time Complexity: O(m + n)</li>
<li>Space Complexity: O(m + n)</li>
</ul>
<h3 id="runtime-stats">Runtime Stats</h3>
<ul>
<li>Runtime: <code>16 ms</code>, faster than <code>6.81%</code> of Java online submissions for Median of Two Sorted Arrays.</li>
<li>Memory Usage: <code>45 MB</code>, less than <code>6.28%</code> of Java online submissions for Median of Two Sorted Arrays.</li>
</ul>
<hr>
<h2 id="15-reverse-nodes-in-k-group---25--hard">15. Reverse Nodes in k-Group - 25 | <code>Hard</code></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.</p>
<p>k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.</p>
<p>You may not alter the values in the list's nodes, only nodes themselves may be changed.</p>
<h3 id="solution">Solution</h3>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>{
        <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;
        ListNode current = head;
        <span class="hljs-keyword">while</span>(current != <span class="hljs-keyword">null</span> &amp;&amp; size &lt; k){
            size++;
            current = current.next;
        }
        <span class="hljs-keyword">if</span>(size &lt; k){
            <span class="hljs-keyword">return</span> head;
        }
        ListNode nextRec = current;        
        ListNode prev = <span class="hljs-keyword">null</span>;
        current = head;
        System.out.println(current.val);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++){
            ListNode next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }
        head.next = reverseKGroup(nextRec, k);
        <span class="hljs-keyword">return</span> prev;
    }
}
</div></code></pre>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(1)</li>
</ul>
<h3 id="runtime-stats">Runtime Stats</h3>
<ul>
<li>Runtime: <code>4 ms</code>, faster than <code>6.84%</code> of Java online submissions for Reverse Nodes in k-Group.</li>
<li>Memory Usage: <code>42.8 MB</code>, less than <code>92.87%</code> of Java online submissions for Reverse Nodes in k-Group.</li>
</ul>
<hr>
<h2 id="stacks">Stacks</h2>
<h3 id="stack-implementation-using-arrays">Stack implementation using Arrays</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * arr, <span class="hljs-keyword">int</span> * top, <span class="hljs-keyword">int</span> data, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-keyword">if</span>(*top &gt;= <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Overflow!\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    arr[++(*top)] = data;
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * arr, <span class="hljs-keyword">int</span> * top)</span></span>{
    <span class="hljs-keyword">if</span>(*top == <span class="hljs-number">-1</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Underflow!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-99999999</span>;
    }
    <span class="hljs-keyword">return</span> arr[(*top)--];
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * arr, <span class="hljs-keyword">int</span> top)</span></span>{
    <span class="hljs-keyword">if</span>(top == <span class="hljs-number">-1</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Stack is empty\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= top; i++){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, arr[i]);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">int</span> stack_size = <span class="hljs-number">50</span>;
    <span class="hljs-keyword">int</span> * <span class="hljs-built_in">stack</span> = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span> (stack_size * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">int</span> choice;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"---\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1 - push and print\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"2 - pop and print\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"3 - exit\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"---\n"</span>);
    <span class="hljs-keyword">do</span>{
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter your choice: "</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;choice);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"---\n"</span>);
        <span class="hljs-keyword">switch</span>(choice){
            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter number to push: "</span>);
                <span class="hljs-keyword">int</span> val;
                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;val);
                push(<span class="hljs-built_in">stack</span>, &amp;top, val, stack_size);
                printArray(<span class="hljs-built_in">stack</span>, top);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Popped element: %d\n"</span>, pop(<span class="hljs-built_in">stack</span>, &amp;top));
                printArray(<span class="hljs-built_in">stack</span>, top);
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"exit\n"</span>);
                <span class="hljs-keyword">break</span>;
        }
        
    } <span class="hljs-keyword">while</span> (choice != <span class="hljs-number">3</span>);
}
</div></code></pre>
<hr>
<h3 id="stack-implementation-using-linked-lists">Stack implementation using Linked Lists</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span>
    <span class="hljs-keyword">int</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">prev</span>;</span>
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>{</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">top</span>;</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;
};

<span class="hljs-function">struct Stack* <span class="hljs-title">createStack</span><span class="hljs-params">()</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span> *<span class="hljs-title">stack</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Stack</span>*) <span class="hljs-title">malloc</span> (<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Stack</span>));</span>
    <span class="hljs-built_in">stack</span>-&gt;top = <span class="hljs-literal">NULL</span>;
    <span class="hljs-built_in">stack</span>-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(struct Stack *<span class="hljs-built_in">stack</span>, <span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">node</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>*) <span class="hljs-title">malloc</span> (<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>));</span>
    node-&gt;data = data;
    node-&gt;next = <span class="hljs-literal">NULL</span>;
    node-&gt;prev = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">stack</span>-&gt;top == <span class="hljs-literal">NULL</span>){
        <span class="hljs-built_in">stack</span>-&gt;top = node;
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-built_in">stack</span>-&gt;top-&gt;next = node;
        node-&gt;prev = <span class="hljs-built_in">stack</span>-&gt;top;
        <span class="hljs-built_in">stack</span>-&gt;top = node;
    }
    <span class="hljs-built_in">stack</span>-&gt;<span class="hljs-built_in">size</span>++;
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(struct Stack *<span class="hljs-built_in">stack</span>)</span></span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">stack</span>-&gt;top == <span class="hljs-literal">NULL</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Underflow!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    <span class="hljs-keyword">int</span> data = <span class="hljs-built_in">stack</span>-&gt;top-&gt;data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> = <span class="hljs-title">stack</span>-&gt;<span class="hljs-title">top</span>;</span>
    <span class="hljs-built_in">stack</span>-&gt;top = <span class="hljs-built_in">stack</span>-&gt;top-&gt;prev;
    <span class="hljs-built_in">free</span>(temp);
    <span class="hljs-built_in">stack</span>-&gt;<span class="hljs-built_in">size</span>--;
    <span class="hljs-keyword">return</span> data;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printStack</span><span class="hljs-params">(struct Stack *<span class="hljs-built_in">stack</span>)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> = <span class="hljs-title">stack</span>-&gt;<span class="hljs-title">top</span>;</span>
    <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|%d| \n"</span>, temp-&gt;data);
        temp = temp-&gt;prev;
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"---\n"</span>);
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span> *<span class="hljs-title">stack</span> = <span class="hljs-title">createStack</span>();</span>
    push(<span class="hljs-built_in">stack</span>, <span class="hljs-number">1</span>);
    push(<span class="hljs-built_in">stack</span>, <span class="hljs-number">2</span>);
    push(<span class="hljs-built_in">stack</span>, <span class="hljs-number">3</span>);
    printStack(<span class="hljs-built_in">stack</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, pop(<span class="hljs-built_in">stack</span>));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, pop(<span class="hljs-built_in">stack</span>));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, pop(<span class="hljs-built_in">stack</span>));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, pop(<span class="hljs-built_in">stack</span>));
    printStack(<span class="hljs-built_in">stack</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h3 id="stack-implementation-using-queues">Stack implementation using Queues</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span>
    <span class="hljs-keyword">int</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">prev</span>;</span>
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span>{</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">front</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">rear</span>;</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;
};

<span class="hljs-function">struct Queue* <span class="hljs-title">createQueue</span><span class="hljs-params">()</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span> *<span class="hljs-title">queue</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Queue</span>*) <span class="hljs-title">malloc</span> (<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Queue</span>));</span>
    <span class="hljs-built_in">queue</span>-&gt;front = <span class="hljs-literal">NULL</span>;
    <span class="hljs-built_in">queue</span>-&gt;rear = <span class="hljs-literal">NULL</span>;
    <span class="hljs-built_in">queue</span>-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>;
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>{</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span> *<span class="hljs-title">queue1</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span> *<span class="hljs-title">queue2</span>;</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;
};

<span class="hljs-function">struct Stack* <span class="hljs-title">createStack</span><span class="hljs-params">()</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span> *<span class="hljs-title">stack</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Stack</span>*) <span class="hljs-title">malloc</span> (<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Stack</span>));</span>
    <span class="hljs-built_in">stack</span>-&gt;queue1 = createQueue();
    <span class="hljs-built_in">stack</span>-&gt;queue2 = createQueue();
    <span class="hljs-built_in">stack</span>-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>;
}

<span class="hljs-function">struct Node* <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">node</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>*) <span class="hljs-title">malloc</span> (<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>));</span>
    node-&gt;data = data;
    node-&gt;next = <span class="hljs-literal">NULL</span>;
    node-&gt;prev = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> node;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(struct Queue *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">node</span> = <span class="hljs-title">getNode</span>(<span class="hljs-title">data</span>);</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">queue</span>-&gt;front == <span class="hljs-literal">NULL</span>){
        <span class="hljs-built_in">queue</span>-&gt;front = node;
        <span class="hljs-built_in">queue</span>-&gt;rear = node;
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-built_in">queue</span>-&gt;rear-&gt;next = node;
        node-&gt;prev = <span class="hljs-built_in">queue</span>-&gt;rear;
        <span class="hljs-built_in">queue</span>-&gt;rear = node;
    }
    <span class="hljs-built_in">queue</span>-&gt;<span class="hljs-built_in">size</span>++;
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dequeue</span><span class="hljs-params">(struct Queue *<span class="hljs-built_in">queue</span>)</span></span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">queue</span>-&gt;front == <span class="hljs-literal">NULL</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Underflow!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    <span class="hljs-keyword">int</span> data = <span class="hljs-built_in">queue</span>-&gt;front-&gt;data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> = <span class="hljs-title">queue</span>-&gt;<span class="hljs-title">front</span>;</span>
    <span class="hljs-built_in">queue</span>-&gt;front = <span class="hljs-built_in">queue</span>-&gt;front-&gt;next;
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">queue</span>-&gt;front == <span class="hljs-literal">NULL</span>){
        <span class="hljs-built_in">queue</span>-&gt;rear = <span class="hljs-literal">NULL</span>;
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-built_in">queue</span>-&gt;front-&gt;prev = <span class="hljs-literal">NULL</span>;
    }
    <span class="hljs-built_in">free</span>(temp);
    <span class="hljs-built_in">queue</span>-&gt;<span class="hljs-built_in">size</span>--;
    <span class="hljs-keyword">return</span> data;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(struct Stack *<span class="hljs-built_in">stack</span>, <span class="hljs-keyword">int</span> data)</span></span>{
    enqueue(<span class="hljs-built_in">stack</span>-&gt;queue1, data);
    <span class="hljs-built_in">stack</span>-&gt;<span class="hljs-built_in">size</span>++;
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(struct Stack *<span class="hljs-built_in">stack</span>)</span></span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">stack</span>-&gt;queue1-&gt;front == <span class="hljs-literal">NULL</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Underflow!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">stack</span>-&gt;queue1-&gt;<span class="hljs-built_in">size</span> &gt; <span class="hljs-number">1</span>)
    {
        enqueue(<span class="hljs-built_in">stack</span>-&gt;queue2, dequeue(<span class="hljs-built_in">stack</span>-&gt;queue1));
    }
    <span class="hljs-keyword">int</span> data = dequeue(<span class="hljs-built_in">stack</span>-&gt;queue1);
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span> *<span class="hljs-title">temp</span> = <span class="hljs-title">stack</span>-&gt;<span class="hljs-title">queue1</span>;</span>
    <span class="hljs-built_in">stack</span>-&gt;queue1 = <span class="hljs-built_in">stack</span>-&gt;queue2;
    <span class="hljs-built_in">stack</span>-&gt;queue2 = temp;
    <span class="hljs-built_in">stack</span>-&gt;<span class="hljs-built_in">size</span>--;
    <span class="hljs-keyword">return</span> data;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printStack</span><span class="hljs-params">(struct Stack *<span class="hljs-built_in">stack</span>)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> = <span class="hljs-title">stack</span>-&gt;<span class="hljs-title">queue1</span>-&gt;<span class="hljs-title">rear</span>;</span>
    <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|%d| \n"</span>, temp-&gt;data);
        temp = temp-&gt;prev;
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"---\n"</span>);
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span> *<span class="hljs-title">stack</span> = <span class="hljs-title">createStack</span>();</span>
    push(<span class="hljs-built_in">stack</span>, <span class="hljs-number">1</span>);
    push(<span class="hljs-built_in">stack</span>, <span class="hljs-number">2</span>);
    push(<span class="hljs-built_in">stack</span>, <span class="hljs-number">3</span>);
    printStack(<span class="hljs-built_in">stack</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, pop(<span class="hljs-built_in">stack</span>));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, pop(<span class="hljs-built_in">stack</span>));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, pop(<span class="hljs-built_in">stack</span>));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, pop(<span class="hljs-built_in">stack</span>));
    printStack(<span class="hljs-built_in">stack</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h3 id="valid-parentheses---20--easy">Valid Parentheses - 20 | <code>Easy</code></h3>
<h4 id="problem-statement">Problem Statement</h4>
<p>Given a string s containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ol>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
<li>Every close bracket has a corresponding open bracket of the same type.</li>
</ol>
<h4 id="solution">Solution</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * arr, <span class="hljs-keyword">int</span> * top, <span class="hljs-keyword">char</span> data, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-keyword">if</span>(*top &gt;= <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Overflow!\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    arr[++(*top)] = data;
    <span class="hljs-keyword">return</span>;
}
<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * arr, <span class="hljs-keyword">int</span> * top)</span></span>{
    <span class="hljs-keyword">if</span>(*top == <span class="hljs-number">-1</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Underflow!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span>;
    }
    <span class="hljs-keyword">return</span> arr[(*top)--];
}


<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* s)</span> </span>{
    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(s);
    <span class="hljs-keyword">char</span> * <span class="hljs-built_in">stack</span> = (<span class="hljs-keyword">char</span> *) <span class="hljs-built_in">malloc</span> (len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));
    <span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
    {
        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">'('</span> || s[i] == <span class="hljs-string">'{'</span> || s[i] == <span class="hljs-string">'['</span>){
            push(<span class="hljs-built_in">stack</span>, &amp;top, s[i], len);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">')'</span>){
            <span class="hljs-keyword">if</span>(pop(<span class="hljs-built_in">stack</span>, &amp;top) != <span class="hljs-string">'('</span>){
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">'}'</span>){
            <span class="hljs-keyword">if</span>(pop(<span class="hljs-built_in">stack</span>, &amp;top) != <span class="hljs-string">'{'</span>){
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">']'</span>){
            <span class="hljs-keyword">if</span>(pop(<span class="hljs-built_in">stack</span>, &amp;top) != <span class="hljs-string">'['</span>){
                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
            }
        }
    }
    <span class="hljs-keyword">if</span>(top == <span class="hljs-number">-1</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(n)</li>
</ul>
<h4 id="runtime-stats">Runtime Stats</h4>
<ul>
<li>Runtime: <code>3 ms</code>, faster than <code>42.5%</code> of C online submissions for Valid Parentheses.</li>
<li>Memory Usage: <code>6.69 MB</code>, less than <code>17.02%</code> of C online submissions for Valid Parentheses.</li>
</ul>
<hr>
<h3 id="baseball-game---682--easy">Baseball Game - 682 | <code>Easy</code></h3>
<h4 id="problem-statement">Problem Statement</h4>
<p>You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.</p>
<p>You are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:</p>
<ul>
<li>An integer x.<br>
Record a new score of x.</li>
<li>'+'.<br>
Record a new score that is the sum of the previous two scores.</li>
<li>'D'.<br>
Record a new score that is the double of the previous score.</li>
<li>'C'.<br>
Invalidate the previous score, removing it from the record.<br>
Return the sum of all the scores on the record after applying all the operations.</li>
</ul>
<p>The test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.</p>
<h4 id="solution">Solution</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * arr, <span class="hljs-keyword">int</span> * top, <span class="hljs-keyword">int</span> data, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-keyword">if</span>(*top &gt;= <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Overflow!\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    arr[++(*top)] = data;
    <span class="hljs-keyword">return</span>;
}


<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">popInt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * arr, <span class="hljs-keyword">int</span> * top)</span></span>{
    <span class="hljs-keyword">if</span>(*top == <span class="hljs-number">-1</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Underflow!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-99999999</span>;
    }
    <span class="hljs-keyword">return</span> arr[(*top)--];
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calPoints</span><span class="hljs-params">(<span class="hljs-keyword">char</span>** operations, <span class="hljs-keyword">int</span> operationsSize)</span> </span>{
    <span class="hljs-keyword">int</span> * <span class="hljs-built_in">stack</span> = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span> (operationsSize * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i &lt; operationsSize; i++){
        <span class="hljs-keyword">if</span>(operations[i][<span class="hljs-number">0</span>] == <span class="hljs-string">'+'</span>){
            <span class="hljs-keyword">int</span> temp = popInt(<span class="hljs-built_in">stack</span>, &amp;top);
            <span class="hljs-keyword">int</span> temp2 = popInt(<span class="hljs-built_in">stack</span>, &amp;top);
            pushInt(<span class="hljs-built_in">stack</span>, &amp;top, temp2, operationsSize);
            pushInt(<span class="hljs-built_in">stack</span>, &amp;top, temp, operationsSize);
            pushInt(<span class="hljs-built_in">stack</span>, &amp;top, temp + temp2, operationsSize);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(operations[i][<span class="hljs-number">0</span>] == <span class="hljs-string">'D'</span>){
            <span class="hljs-keyword">int</span> temp = popInt(<span class="hljs-built_in">stack</span>, &amp;top);
            pushInt(<span class="hljs-built_in">stack</span>, &amp;top, temp, operationsSize);
            pushInt(<span class="hljs-built_in">stack</span>, &amp;top, temp * <span class="hljs-number">2</span>, operationsSize);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(operations[i][<span class="hljs-number">0</span>] == <span class="hljs-string">'C'</span>){
            popInt(<span class="hljs-built_in">stack</span>, &amp;top);
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">int</span> temp = atoi(operations[i]);
            pushInt(<span class="hljs-built_in">stack</span>, &amp;top, temp, operationsSize);
        }
    }
    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(top &gt; <span class="hljs-number">-1</span>){
        res += popInt(<span class="hljs-built_in">stack</span>, &amp;top);
    }
    <span class="hljs-keyword">return</span> res;
}
</div></code></pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(n)</li>
</ul>
<h4 id="runtime-stats">Runtime Stats</h4>
<ul>
<li>Runtime: <code>0 ms</code>, faster than <code>100.00%</code> of C online submissions for Baseball Game.</li>
<li>Memory Usage: <code>6.96 MB</code>, less than <code>33.46%</code> of C online submissions for Baseball Game.</li>
</ul>
<hr>
<h2 id="infix-to-postfix-conversion">Infix to Postfix Conversion</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">precedence</span><span class="hljs-params">(<span class="hljs-keyword">char</span> op)</span></span>{
    <span class="hljs-keyword">switch</span> (op)
    {
    <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:
    <span class="hljs-keyword">case</span> <span class="hljs-string">'%'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-string">'^'</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;
        <span class="hljs-keyword">break</span>;    
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">break</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * arr, <span class="hljs-keyword">int</span> * top, <span class="hljs-keyword">char</span> data, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-keyword">if</span>(*top &gt;= <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Overflow!\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    arr[++(*top)] = data;
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * arr, <span class="hljs-keyword">int</span> * top)</span></span>{
    <span class="hljs-keyword">if</span>(*top == <span class="hljs-number">-1</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Underflow!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">'|'</span>;
    }
    <span class="hljs-keyword">return</span> arr[(*top)--];
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_float</span><span class="hljs-params">(<span class="hljs-keyword">float</span> * arr, <span class="hljs-keyword">int</span> * top, <span class="hljs-keyword">float</span> data, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-keyword">if</span>(*top &gt;= <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Overflow!\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    arr[++(*top)] = data;
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">pop_float</span><span class="hljs-params">(<span class="hljs-keyword">float</span> * arr, <span class="hljs-keyword">int</span> * top)</span></span>{
    <span class="hljs-keyword">if</span>(*top == <span class="hljs-number">-1</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Underflow!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-string">'|'</span>;
    }
    <span class="hljs-keyword">return</span> arr[(*top)--];
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * arr, <span class="hljs-keyword">int</span> top)</span></span>{
    <span class="hljs-keyword">if</span>(top == <span class="hljs-number">-1</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Stack is empty\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= top; i++){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c\t"</span>, arr[i]);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">char</span> * <span class="hljs-title">toPostfix</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * infix)</span></span>{
    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(infix);
    <span class="hljs-keyword">char</span> * postfix = (<span class="hljs-keyword">char</span> *) <span class="hljs-built_in">malloc</span> ((len+<span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));
    <span class="hljs-keyword">char</span> * operators = (<span class="hljs-keyword">char</span> *) <span class="hljs-built_in">malloc</span> ((len+<span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));
    <span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>, pin = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
    {
        <span class="hljs-keyword">if</span>(infix[i] &gt;= <span class="hljs-string">'0'</span> &amp;&amp; infix[i] &lt;= <span class="hljs-string">'9'</span>){
            postfix[++pin] = infix[i];
            <span class="hljs-keyword">if</span>(i &lt; len - <span class="hljs-number">1</span> &amp;&amp; !<span class="hljs-built_in">isalnum</span>(infix[i+<span class="hljs-number">1</span>])){
                postfix[++pin] = <span class="hljs-string">' '</span>;
            }
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isalnum</span>(infix[i]))
        {
            postfix[++pin] = infix[i];

        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(infix[i] == <span class="hljs-string">'('</span>){
            push(operators, &amp;top, infix[i], len);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (infix[i] == <span class="hljs-string">')'</span>) {
            <span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">-1</span> &amp;&amp; operators[top] != <span class="hljs-string">'('</span>) {
                postfix[++pin] = pop(operators, &amp;top);
            }
            <span class="hljs-keyword">if</span> (top &gt; <span class="hljs-number">-1</span> &amp;&amp; operators[top] == <span class="hljs-string">'('</span>) {
                pop(operators, &amp;top);
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Invalid expression!\n"</span>);
                <span class="hljs-built_in">free</span>(postfix);
                <span class="hljs-built_in">free</span>(operators);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
            }
        }

        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(precedence(infix[i])){
            <span class="hljs-keyword">char</span> op;
            <span class="hljs-keyword">while</span> ((top &gt; <span class="hljs-number">-1</span> &amp;&amp; precedence(operators[top]) &gt;= precedence(infix[i])) &amp;&amp; operators[top] != <span class="hljs-string">'('</span>)
            {
                postfix[++pin] = pop(operators, &amp;top);
            }
            push(operators, &amp;top, infix[i], len);
        }
    }
    <span class="hljs-keyword">while</span> (top &gt; <span class="hljs-number">-1</span>)
    {
        <span class="hljs-keyword">if</span>(operators[top] == <span class="hljs-string">'('</span>){
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Invalid expression!\n"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        }
        postfix[++pin] = pop(operators, &amp;top);
    }
    postfix[++pin] = <span class="hljs-string">'\0'</span>;
    <span class="hljs-keyword">return</span> postfix;    
}
</div></code></pre>
<hr>
<h2 id="postfix-evaluation">Postfix Evaluation</h2>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">eval_postfix</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *postfix)</span></span>{
    <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">strlen</span>(postfix);
    <span class="hljs-keyword">float</span> * operands = (<span class="hljs-keyword">float</span> *) <span class="hljs-built_in">malloc</span> (len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>)); <span class="hljs-comment">// change to float array</span>
    <span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">float</span> current = <span class="hljs-number">0</span>; <span class="hljs-comment">// change to float</span>
    <span class="hljs-keyword">int</span> digitFlag = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)
    {
        <span class="hljs-keyword">if</span> (postfix[i] == <span class="hljs-string">' '</span>)
        {
            <span class="hljs-keyword">if</span> (digitFlag) { <span class="hljs-comment">// if we're in the middle of a number, push it to the stack</span>
                push_float(operands, &amp;top, current, len);
                current = <span class="hljs-number">0</span>;
                digitFlag = <span class="hljs-number">0</span>;
            }
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(postfix[i])){
            current = current * <span class="hljs-number">10</span> + (postfix[i] - <span class="hljs-string">'0'</span>);
            digitFlag = <span class="hljs-number">1</span>; <span class="hljs-comment">// set the flag to indicate we're in the middle of a number</span>
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-keyword">if</span>(precedence(postfix[i])){
            <span class="hljs-keyword">if</span> (digitFlag) { <span class="hljs-comment">// if we're in the middle of a number, push it to the stack</span>
                push_float(operands, &amp;top, current, len);
                current = <span class="hljs-number">0</span>;
                digitFlag = <span class="hljs-number">0</span>;
            }
            <span class="hljs-keyword">float</span> op2 = pop_float(operands, &amp;top); <span class="hljs-comment">// change to pop_float</span>
            <span class="hljs-keyword">float</span> op1 = pop_float(operands, &amp;top); <span class="hljs-comment">// change to pop_float</span>
            <span class="hljs-keyword">switch</span> (postfix[i])
            {
            <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:
                push_float(operands, &amp;top, op1 + op2, len); <span class="hljs-comment">// change to push_float</span>
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:
                push_float(operands, &amp;top, op1 - op2, len); <span class="hljs-comment">// change to push_float</span>
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:
                push_float(operands, &amp;top, op1 * op2, len); <span class="hljs-comment">// change to push_float</span>
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:
                <span class="hljs-keyword">if</span> (op2 != <span class="hljs-number">0</span>) {
                    push_float(operands, &amp;top, (<span class="hljs-keyword">float</span>)op1 / op2, len); <span class="hljs-comment">// change to push_float</span>
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error: Division by zero\n"</span>);
                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
                }
                <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">default</span>:
                <span class="hljs-keyword">break</span>;
            }
        }
    }
    <span class="hljs-keyword">return</span> operands[top];
}
</div></code></pre>
<hr>
<h2 id="queues">Queues</h2>
<h3 id="queue-implementation-using-arrays">Queue implementation using Arrays</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * arr, <span class="hljs-keyword">int</span> *front, <span class="hljs-keyword">int</span> * rear, <span class="hljs-keyword">int</span> data, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-comment">// empty check</span>
    <span class="hljs-keyword">if</span> (*front == <span class="hljs-number">-1</span> &amp;&amp; *rear == <span class="hljs-number">-1</span>)
    {
        arr[<span class="hljs-number">0</span>] = data;
        *front = <span class="hljs-number">0</span>;
        *rear = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// overflow</span>
    <span class="hljs-keyword">if</span> ((*front == <span class="hljs-number">0</span> &amp;&amp; *rear == <span class="hljs-built_in">size</span><span class="hljs-number">-1</span>) || (*front - *rear == <span class="hljs-number">1</span>))
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Overflow!\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// not overflow, but rear is at end</span>
    <span class="hljs-keyword">if</span>(*rear == <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>){
        *rear = <span class="hljs-number">0</span>;
        arr[*rear] = data;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// normal case</span>
    arr[++(*rear)] = data;
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dequeue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> *front, <span class="hljs-keyword">int</span> *rear, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-comment">// empty check</span>
    <span class="hljs-keyword">if</span> (*front == <span class="hljs-number">-1</span> &amp;&amp; *rear == <span class="hljs-number">-1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Empty queue\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-999999</span>;
    }
    <span class="hljs-comment">// one element</span>
    <span class="hljs-keyword">if</span> (*front == *rear)
    {
        <span class="hljs-keyword">int</span> data = arr[*front];
        *front = <span class="hljs-number">-1</span>;
        *rear = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">return</span> data;
    }
    <span class="hljs-comment">// front at end</span>
    <span class="hljs-keyword">if</span> (*front == <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">int</span> data = arr[*front];
        *front = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> data;
    }
    <span class="hljs-comment">//normal case</span>
    <span class="hljs-keyword">return</span> arr[(*front)++];    
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * arr, <span class="hljs-keyword">int</span> front, <span class="hljs-keyword">int</span> rear)</span></span>{
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span> = <span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);
    <span class="hljs-keyword">if</span> (front == <span class="hljs-number">-1</span> &amp;&amp; rear == <span class="hljs-number">-1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Empty queue\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (rear &lt; front)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = front; i &lt; <span class="hljs-built_in">size</span>; i++)
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, arr[i]);
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= rear; i++)
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, arr[i]);
        }   
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);    
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = front; i &lt;= rear; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, arr[i]);
    }        
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}
</div></code></pre>
<hr>
<h3 id="queue-implementation-using-linked-lists">Queue implementation using Linked Lists</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span>
    <span class="hljs-keyword">int</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">next</span>;</span>
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span>{</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">front</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">rear</span>;</span>
};

<span class="hljs-function">struct Queue * <span class="hljs-title">createQueue</span><span class="hljs-params">()</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span> * <span class="hljs-title">q</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Queue</span> *)<span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Queue</span>));</span>
    q-&gt;front = <span class="hljs-literal">NULL</span>;
    q-&gt;rear = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> q;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(struct Queue * <span class="hljs-built_in">queue</span>, <span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">newNode</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Node</span> *)<span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>));</span>
    newNode-&gt;data = data;
    <span class="hljs-comment">// empty</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>-&gt;front == <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-built_in">queue</span>-&gt;rear == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">queue</span>-&gt;front = newNode;
        <span class="hljs-built_in">queue</span>-&gt;rear = newNode;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">queue</span>-&gt;rear-&gt;next = newNode;
    <span class="hljs-built_in">queue</span>-&gt;rear = newNode;    
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dequeue</span><span class="hljs-params">(struct Queue * <span class="hljs-built_in">queue</span>)</span></span>{
    <span class="hljs-comment">// last element</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>-&gt;front == <span class="hljs-built_in">queue</span>-&gt;rear)
    {
        <span class="hljs-keyword">int</span> data = <span class="hljs-built_in">queue</span>-&gt;front-&gt;data;
        <span class="hljs-built_in">queue</span>-&gt;front = <span class="hljs-literal">NULL</span>;
        <span class="hljs-built_in">queue</span>-&gt;rear = <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">return</span> data;
    }
    <span class="hljs-comment">// empty queue</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>-&gt;front == <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-built_in">queue</span>-&gt;rear == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Underflow!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-999999</span>;
    }
    <span class="hljs-keyword">int</span> data = <span class="hljs-built_in">queue</span>-&gt;front-&gt;data;
    <span class="hljs-built_in">queue</span>-&gt;front = <span class="hljs-built_in">queue</span>-&gt;front-&gt;next;
    <span class="hljs-keyword">return</span> data;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printQueue</span><span class="hljs-params">(struct Queue * <span class="hljs-built_in">queue</span>)</span></span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">queue</span>-&gt;front == <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-built_in">queue</span>-&gt;rear == <span class="hljs-literal">NULL</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Empty queue\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">temp</span> = <span class="hljs-title">queue</span>-&gt;<span class="hljs-title">front</span>;</span>
    <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, temp-&gt;data);
        temp = temp-&gt;next;
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}
</div></code></pre>
<hr>
<h3 id="implement-stack-using-queues">Implement Stack using Queues</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span>
    <span class="hljs-keyword">int</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">prev</span>;</span>
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span>{</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">top</span>;</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;
};

<span class="hljs-function">struct Stack* <span class="hljs-title">createStack</span><span class="hljs-params">()</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span> *<span class="hljs-title">stack</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Stack</span>*) <span class="hljs-title">malloc</span> (<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Stack</span>));</span>
    <span class="hljs-built_in">stack</span>-&gt;top = <span class="hljs-literal">NULL</span>;
    <span class="hljs-built_in">stack</span>-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>;
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span>{</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span> *<span class="hljs-title">stack1</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Stack</span> *<span class="hljs-title">stack2</span>;</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;
};

<span class="hljs-function">struct Queue* <span class="hljs-title">createQueue</span><span class="hljs-params">()</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span> *<span class="hljs-title">queue</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Queue</span>*) <span class="hljs-title">malloc</span> (<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Queue</span>));</span>
    <span class="hljs-built_in">queue</span>-&gt;stack1 = createStack();
    <span class="hljs-built_in">queue</span>-&gt;stack2 = createStack();
    <span class="hljs-built_in">queue</span>-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>;
}

<span class="hljs-function">struct Node* <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">node</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>*) <span class="hljs-title">malloc</span> (<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>));</span>
    node-&gt;data = data;
    node-&gt;next = <span class="hljs-literal">NULL</span>;
    node-&gt;prev = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> node;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(struct Stack *<span class="hljs-built_in">stack</span>, <span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">node</span> = <span class="hljs-title">getNode</span>(<span class="hljs-title">data</span>);</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">stack</span>-&gt;top == <span class="hljs-literal">NULL</span>){
        <span class="hljs-built_in">stack</span>-&gt;top = node;
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-built_in">stack</span>-&gt;top-&gt;next = node;
        node-&gt;prev = <span class="hljs-built_in">stack</span>-&gt;top;
        <span class="hljs-built_in">stack</span>-&gt;top = node;
    }
    <span class="hljs-built_in">stack</span>-&gt;<span class="hljs-built_in">size</span>++;
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">(struct Stack *<span class="hljs-built_in">stack</span>)</span></span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">stack</span>-&gt;top == <span class="hljs-literal">NULL</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Underflow!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    <span class="hljs-keyword">int</span> data = <span class="hljs-built_in">stack</span>-&gt;top-&gt;data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> = <span class="hljs-title">stack</span>-&gt;<span class="hljs-title">top</span>;</span>
    <span class="hljs-built_in">stack</span>-&gt;top = <span class="hljs-built_in">stack</span>-&gt;top-&gt;prev;
    <span class="hljs-built_in">free</span>(temp);
    <span class="hljs-built_in">stack</span>-&gt;<span class="hljs-built_in">size</span>--;
    <span class="hljs-keyword">return</span> data;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(struct Queue *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">int</span> data)</span></span>{
    push(<span class="hljs-built_in">queue</span>-&gt;stack1, data);
    <span class="hljs-built_in">queue</span>-&gt;<span class="hljs-built_in">size</span>++;
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dequeue</span><span class="hljs-params">(struct Queue *<span class="hljs-built_in">queue</span>)</span></span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">queue</span>-&gt;stack1-&gt; <span class="hljs-built_in">size</span> == <span class="hljs-number">0</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Underflow!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">queue</span>-&gt;stack1-&gt;<span class="hljs-built_in">size</span> != <span class="hljs-number">1</span>)
    {
        push(<span class="hljs-built_in">queue</span>-&gt;stack2, pop(<span class="hljs-built_in">queue</span>-&gt;stack1));
    }
    <span class="hljs-keyword">int</span> data = pop(<span class="hljs-built_in">queue</span>-&gt;stack1);
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">queue</span>-&gt;stack2-&gt;<span class="hljs-built_in">size</span> != <span class="hljs-number">0</span>)
    {
        push(<span class="hljs-built_in">queue</span>-&gt;stack1, pop(<span class="hljs-built_in">queue</span>-&gt;stack2));
    }
    <span class="hljs-built_in">queue</span>-&gt;<span class="hljs-built_in">size</span>--;
    <span class="hljs-keyword">return</span> data;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printQueue</span><span class="hljs-params">(struct Queue *<span class="hljs-built_in">queue</span>)</span></span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">queue</span>-&gt;stack1-&gt;<span class="hljs-built_in">size</span> == <span class="hljs-number">0</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Queue is empty!\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">queue</span>-&gt;stack1-&gt;<span class="hljs-built_in">size</span> != <span class="hljs-number">0</span>)
    {
        push(<span class="hljs-built_in">queue</span>-&gt;stack2, pop(<span class="hljs-built_in">queue</span>-&gt;stack1));
    }
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">queue</span>-&gt;stack2-&gt;<span class="hljs-built_in">size</span> != <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">int</span> data = pop(<span class="hljs-built_in">queue</span>-&gt;stack2);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|%d| \n"</span>, data);
        push(<span class="hljs-built_in">queue</span>-&gt;stack1, data);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"---\n"</span>);
    <span class="hljs-keyword">return</span>;
}
</div></code></pre>
<hr>
<h3 id="deque-implementation-using-arrays">Deque implementation using Arrays</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue_front</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">int</span> *front, <span class="hljs-keyword">int</span> *rear, <span class="hljs-keyword">int</span> data, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-comment">// empty check</span>
    <span class="hljs-keyword">if</span> (*front == <span class="hljs-number">-1</span> &amp;&amp; *rear == <span class="hljs-number">-1</span>)
    {
        <span class="hljs-built_in">queue</span>[<span class="hljs-number">0</span>] = data;
        *front = <span class="hljs-number">0</span>;
        *rear = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">//overflow</span>
    <span class="hljs-keyword">if</span>((*front == <span class="hljs-number">0</span> &amp;&amp; *rear == <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>) || (*front - *rear == <span class="hljs-number">1</span>)){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Overflow!\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// not overflow, but front is at start</span>
    <span class="hljs-keyword">if</span>(*front == <span class="hljs-number">0</span>){
        *front = <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>;
        <span class="hljs-built_in">queue</span>[*front] = data;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// normal case</span>
    <span class="hljs-built_in">queue</span>[--(*front)] = data;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue_rear</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">int</span> *front, <span class="hljs-keyword">int</span> *rear, <span class="hljs-keyword">int</span> data, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-comment">// empty check</span>
    <span class="hljs-keyword">if</span> (*front == <span class="hljs-number">-1</span> &amp;&amp; *rear == <span class="hljs-number">-1</span>)
    {
        <span class="hljs-built_in">queue</span>[<span class="hljs-number">0</span>] = data;
        *front = <span class="hljs-number">0</span>;
        *rear = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">//overflow</span>
    <span class="hljs-keyword">if</span>((*front == <span class="hljs-number">0</span> &amp;&amp; *rear == <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>) || (*front - *rear == <span class="hljs-number">1</span>)){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Overflow!\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// not overflow, but rear is at end</span>
    <span class="hljs-keyword">if</span>(*rear == <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>){
        *rear = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">queue</span>[*rear] = data;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// normal case</span>
    <span class="hljs-built_in">queue</span>[++(*rear)] = data;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dequeue_front</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">int</span> *front, <span class="hljs-keyword">int</span> *rear, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-comment">// empty check</span>
    <span class="hljs-keyword">if</span> (*front == <span class="hljs-number">-1</span> &amp;&amp; *rear == <span class="hljs-number">-1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Empty queue\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-999999</span>;
    }
    <span class="hljs-comment">// one element</span>
    <span class="hljs-keyword">if</span> (*front == *rear)
    {
        <span class="hljs-keyword">int</span> data = <span class="hljs-built_in">queue</span>[*front];
        *front = <span class="hljs-number">-1</span>;
        *rear = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">return</span> data;
    }
    <span class="hljs-comment">// front at end</span>
    <span class="hljs-keyword">if</span> (*front == <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">int</span> data = <span class="hljs-built_in">queue</span>[*front];
        *front = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> data;
    }
    <span class="hljs-comment">//normal case</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>[(*front)++];
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dequeue_rear</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *<span class="hljs-built_in">queue</span>, <span class="hljs-keyword">int</span> *front, <span class="hljs-keyword">int</span> *rear, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-comment">// empty check</span>
    <span class="hljs-keyword">if</span> (*front == <span class="hljs-number">-1</span> &amp;&amp; *rear == <span class="hljs-number">-1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Empty queue\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-999999</span>;
    }
    <span class="hljs-comment">// one element</span>
    <span class="hljs-keyword">if</span> (*front == *rear)
    {
        <span class="hljs-keyword">int</span> data = <span class="hljs-built_in">queue</span>[*front];
        *front = <span class="hljs-number">-1</span>;
        *rear = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">return</span> data;
    }
    <span class="hljs-comment">// rear at start</span>
    <span class="hljs-keyword">if</span> (*rear == <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">int</span> data = <span class="hljs-built_in">queue</span>[*rear];
        *rear = <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> data;
    }
    <span class="hljs-comment">//normal case</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">queue</span>[(*rear)--];
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * arr, <span class="hljs-keyword">int</span> front, <span class="hljs-keyword">int</span> rear, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-keyword">if</span> (front == <span class="hljs-number">-1</span> &amp;&amp; rear == <span class="hljs-number">-1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Empty queue\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (rear &lt; front)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = front; i &lt; <span class="hljs-built_in">size</span>; i++)
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, arr[i]);
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= rear; i++)
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, arr[i]);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = front; i &lt;= rear; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, arr[i]);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// menu driven</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter size of queue: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;<span class="hljs-built_in">size</span>);
    <span class="hljs-keyword">int</span> * <span class="hljs-built_in">queue</span> = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span> (<span class="hljs-built_in">size</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-keyword">int</span> front = <span class="hljs-number">-1</span>, rear = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">int</span> choice = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (choice != <span class="hljs-number">5</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1. Enqueue front\n2. Enqueue rear\n3. Dequeue front\n4. Dequeue rear\n5. Exit\nEnter choice: "</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;choice);
        <span class="hljs-keyword">switch</span> (choice)
        {
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data: "</span>);
            <span class="hljs-keyword">int</span> data;
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
            enqueue_front(<span class="hljs-built_in">queue</span>, &amp;front, &amp;rear, data, <span class="hljs-built_in">size</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data: "</span>);
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
            enqueue_rear(<span class="hljs-built_in">queue</span>, &amp;front, &amp;rear, data, <span class="hljs-built_in">size</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Dequeued %d\n"</span>, dequeue_front(<span class="hljs-built_in">queue</span>, &amp;front, &amp;rear, <span class="hljs-built_in">size</span>));
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Dequeued %d\n"</span>, dequeue_rear(<span class="hljs-built_in">queue</span>, &amp;front, &amp;rear, <span class="hljs-built_in">size</span>));
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Exiting...\n"</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Invalid choice\n"</span>);
            <span class="hljs-keyword">break</span>;
        }
        printArray(<span class="hljs-built_in">queue</span>, front, rear, <span class="hljs-built_in">size</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h3 id="deque-implementation-using-linked-lists">Deque implementation using Linked Lists</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span>
    <span class="hljs-keyword">int</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">next</span>;</span>
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span>{</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">front</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">rear</span>;</span>
};

<span class="hljs-function">struct Queue * <span class="hljs-title">createQueue</span><span class="hljs-params">()</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span> * <span class="hljs-title">q</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Queue</span> *)<span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Queue</span>));</span>
    q-&gt;front = <span class="hljs-literal">NULL</span>;
    q-&gt;rear = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> q;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue_front</span><span class="hljs-params">(struct Queue * <span class="hljs-built_in">queue</span>, <span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">newNode</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Node</span> *)<span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>));</span>
    newNode-&gt;data = data;
    <span class="hljs-comment">// empty</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>-&gt;front == <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-built_in">queue</span>-&gt;rear == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">queue</span>-&gt;front = newNode;
        <span class="hljs-built_in">queue</span>-&gt;rear = newNode;
        <span class="hljs-keyword">return</span>;
    }
    newNode-&gt;next = <span class="hljs-built_in">queue</span>-&gt;front;
    <span class="hljs-built_in">queue</span>-&gt;front = newNode;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue_rear</span><span class="hljs-params">(struct Queue * <span class="hljs-built_in">queue</span>, <span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">newNode</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Node</span> *)<span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>));</span>
    newNode-&gt;data = data;
    <span class="hljs-comment">// empty</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>-&gt;front == <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-built_in">queue</span>-&gt;rear == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">queue</span>-&gt;front = newNode;
        <span class="hljs-built_in">queue</span>-&gt;rear = newNode;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">queue</span>-&gt;rear-&gt;next = newNode;
    <span class="hljs-built_in">queue</span>-&gt;rear = newNode;    
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dequeue_front</span><span class="hljs-params">(struct Queue * <span class="hljs-built_in">queue</span>)</span></span>{
    <span class="hljs-comment">// last element</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>-&gt;front == <span class="hljs-built_in">queue</span>-&gt;rear)
    {
        <span class="hljs-keyword">int</span> data = <span class="hljs-built_in">queue</span>-&gt;front-&gt;data;
        <span class="hljs-built_in">queue</span>-&gt;front = <span class="hljs-literal">NULL</span>;
        <span class="hljs-built_in">queue</span>-&gt;rear = <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">return</span> data;
    }
    <span class="hljs-comment">// empty queue</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>-&gt;front == <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-built_in">queue</span>-&gt;rear == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Underflow!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-999999</span>;
    }
    <span class="hljs-keyword">int</span> data = <span class="hljs-built_in">queue</span>-&gt;front-&gt;data;
    <span class="hljs-built_in">queue</span>-&gt;front = <span class="hljs-built_in">queue</span>-&gt;front-&gt;next;
    <span class="hljs-keyword">return</span> data;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dequeue_rear</span><span class="hljs-params">(struct Queue * <span class="hljs-built_in">queue</span>)</span></span>{
    <span class="hljs-comment">// last element</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>-&gt;front == <span class="hljs-built_in">queue</span>-&gt;rear)
    {
        <span class="hljs-keyword">int</span> data = <span class="hljs-built_in">queue</span>-&gt;front-&gt;data;
        <span class="hljs-built_in">queue</span>-&gt;front = <span class="hljs-literal">NULL</span>;
        <span class="hljs-built_in">queue</span>-&gt;rear = <span class="hljs-literal">NULL</span>;
        <span class="hljs-keyword">return</span> data;
    }
    <span class="hljs-comment">// empty queue</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>-&gt;front == <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-built_in">queue</span>-&gt;rear == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Underflow!\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-999999</span>;
    }
    <span class="hljs-keyword">int</span> data = <span class="hljs-built_in">queue</span>-&gt;rear-&gt;data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">temp</span> = <span class="hljs-title">queue</span>-&gt;<span class="hljs-title">front</span>;</span>
    <span class="hljs-keyword">while</span> (temp-&gt;next != <span class="hljs-built_in">queue</span>-&gt;rear)
    {
        temp = temp-&gt;next;
    }
    temp-&gt;next = <span class="hljs-literal">NULL</span>;
    <span class="hljs-built_in">queue</span>-&gt;rear = temp;
    <span class="hljs-keyword">return</span> data;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printQueue</span><span class="hljs-params">(struct Queue * <span class="hljs-built_in">queue</span>)</span></span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">queue</span>-&gt;front == <span class="hljs-literal">NULL</span> &amp;&amp; <span class="hljs-built_in">queue</span>-&gt;rear == <span class="hljs-literal">NULL</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Empty queue\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">temp</span> = <span class="hljs-title">queue</span>-&gt;<span class="hljs-title">front</span>;</span>
    <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, temp-&gt;data);
        temp = temp-&gt;next;
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span> * <span class="hljs-title">queue</span> = <span class="hljs-title">createQueue</span>();</span>
    enqueue_front(<span class="hljs-built_in">queue</span>, <span class="hljs-number">1</span>);
    enqueue_front(<span class="hljs-built_in">queue</span>, <span class="hljs-number">2</span>);
    enqueue_front(<span class="hljs-built_in">queue</span>, <span class="hljs-number">3</span>);
    enqueue_front(<span class="hljs-built_in">queue</span>, <span class="hljs-number">4</span>);
    enqueue_front(<span class="hljs-built_in">queue</span>, <span class="hljs-number">5</span>);
    enqueue_rear(<span class="hljs-built_in">queue</span>, <span class="hljs-number">6</span>);
    enqueue_rear(<span class="hljs-built_in">queue</span>, <span class="hljs-number">7</span>);
    enqueue_rear(<span class="hljs-built_in">queue</span>, <span class="hljs-number">8</span>);
    enqueue_rear(<span class="hljs-built_in">queue</span>, <span class="hljs-number">9</span>);
    enqueue_rear(<span class="hljs-built_in">queue</span>, <span class="hljs-number">10</span>);
    printQueue(<span class="hljs-built_in">queue</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, dequeue_front(<span class="hljs-built_in">queue</span>));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, dequeue_front(<span class="hljs-built_in">queue</span>));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, dequeue_front(<span class="hljs-built_in">queue</span>));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, dequeue_front(<span class="hljs-built_in">queue</span>));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, dequeue_front(<span class="hljs-built_in">queue</span>));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, dequeue_rear(<span class="hljs-built_in">queue</span>));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, dequeue_rear(<span class="hljs-built_in">queue</span>));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, dequeue_rear(<span class="hljs-built_in">queue</span>));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, dequeue_rear(<span class="hljs-built_in">queue</span>));
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, dequeue_rear(<span class="hljs-built_in">queue</span>));
    printQueue(<span class="hljs-built_in">queue</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="priority-queues">Priority Queues</h2>
<h3 id="priority-queue-implementation-using-linked-lists">Priority Queue implementation using Linked Lists</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span>
    <span class="hljs-keyword">int</span> data;
    <span class="hljs-keyword">int</span> priority;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">next</span>;</span>
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span>{</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">front</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">rear</span>;</span>
};

<span class="hljs-function">struct Queue ** <span class="hljs-title">createPriorityQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span> **<span class="hljs-title">pq</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Queue</span> **)<span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Queue</span> *) * <span class="hljs-title">size</span>);</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; i++)
    {
        pq[i] = (struct Queue *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(struct Queue));
        pq[i]-&gt;front = <span class="hljs-literal">NULL</span>;
        pq[i]-&gt;rear = <span class="hljs-literal">NULL</span>;
    }
    <span class="hljs-keyword">return</span> pq;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(struct Queue **pq, <span class="hljs-keyword">int</span> data, <span class="hljs-keyword">int</span> priority)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Node</span> *)<span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>));</span>
    newNode-&gt;data = data;
    <span class="hljs-comment">// empty check</span>
    <span class="hljs-keyword">if</span> (pq[priority]-&gt;front == <span class="hljs-literal">NULL</span> &amp;&amp; pq[priority]-&gt;rear == <span class="hljs-literal">NULL</span>)
    {
        newNode-&gt;next = <span class="hljs-literal">NULL</span>;
        pq[priority]-&gt;front = newNode;
        pq[priority]-&gt;rear = newNode;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// non-empty</span>
    pq[priority]-&gt;rear-&gt;next = newNode;
    pq[priority]-&gt;rear = newNode;
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dequeue</span><span class="hljs-params">(struct Queue **pq, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; i++){
        <span class="hljs-keyword">if</span>(pq[i]-&gt;front != <span class="hljs-literal">NULL</span>){
            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> = <span class="hljs-title">pq</span>[<span class="hljs-title">i</span>]-&gt;<span class="hljs-title">front</span>;</span>
            <span class="hljs-keyword">int</span> data = temp-&gt;data;
            pq[i]-&gt;front = pq[i]-&gt;front-&gt;next;
            <span class="hljs-built_in">free</span>(temp);
            <span class="hljs-keyword">return</span> data;
        }
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Queue is empty!\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printQueue</span><span class="hljs-params">(struct Queue **pq, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; i++){
        <span class="hljs-keyword">if</span>(pq[i]-&gt;front == <span class="hljs-literal">NULL</span>){
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Queue %d is empty\n"</span>, i);
            <span class="hljs-keyword">continue</span>;
        }
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> = <span class="hljs-title">pq</span>[<span class="hljs-title">i</span>]-&gt;<span class="hljs-title">front</span>;</span>
        <span class="hljs-keyword">while</span>(temp != <span class="hljs-literal">NULL</span>){
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\t"</span>, temp-&gt;data);
            temp = temp-&gt;next;
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>, data, priority, choice;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter the number of queues: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;<span class="hljs-built_in">size</span>);
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Queue</span> **<span class="hljs-title">pq</span> = <span class="hljs-title">createPriorityQueue</span>(<span class="hljs-title">size</span>);</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"1. Enqueue\n2. Dequeue\n3. Print\n4. Exit\nEnter your choice: "</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;choice);
        <span class="hljs-keyword">switch</span> (choice)
        {
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data and priority: "</span>);
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;data, &amp;priority);
            enqueue(pq, data, priority);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Dequeued %d\n"</span>, dequeue(pq, <span class="hljs-built_in">size</span>));
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
            printQueue(pq, <span class="hljs-built_in">size</span>);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
        <span class="hljs-keyword">default</span>:
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Invalid choice!\n"</span>);
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h2 id="trees">Trees</h2>
<h3 id="binary-tree-implementation-using-linked-lists">Binary tree implementation using Linked Lists</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
{</span>
    <span class="hljs-keyword">int</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">left</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">right</span>;</span>
};

<span class="hljs-function">struct Node * <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Node</span> *)<span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>));</span>
    newNode-&gt;data = data;
    newNode-&gt;left = <span class="hljs-literal">NULL</span>;
    newNode-&gt;right = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> newNode;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(struct Node * node)</span></span>{
    <span class="hljs-keyword">int</span> data, choice;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Do you want to enter left child of %d? (1/0): "</span>, node-&gt;data);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;choice);
    <span class="hljs-keyword">if</span> (choice == <span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data: "</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
        node-&gt;left = getNode(data);
        buildTree(node-&gt;left);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Do you want to enter right child of %d? (1/0): "</span>, node-&gt;data);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;choice);
    <span class="hljs-keyword">if</span> (choice == <span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data: "</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
        node-&gt;right = getNode(data);
        buildTree(node-&gt;right);
    }   
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">display</span>(root-&gt;left);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, root-&gt;data);
    <span class="hljs-built_in">display</span>(root-&gt;right);    
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display_tree</span><span class="hljs-params">(struct Node *root, <span class="hljs-keyword">int</span> level)</span></span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    display_tree(root-&gt;right, level + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|\t"</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|------&gt;%d\n"</span>, root-&gt;data);
    display_tree(root-&gt;left, level + <span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">root</span> = <span class="hljs-title">NULL</span>;</span>
    <span class="hljs-keyword">int</span> num;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;num);
    root = getNode(num);
    buildTree(root);
    display_tree(root, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h3 id="binary-tree-implementation-using-arrays">Binary Tree implementation using Arrays</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> * <span class="hljs-title">createTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">int</span> *tree = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">calloc</span>((<span class="hljs-keyword">int</span>)((<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, (<span class="hljs-keyword">double</span>)(num))) - <span class="hljs-number">1</span>), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-keyword">return</span> tree;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span> (tree[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data: "</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;tree[<span class="hljs-number">0</span>]);
    }
    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">int</span> data, choice;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Do you want to enter left child of %d? (1/0): "</span>, tree[index]);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;choice);
    <span class="hljs-keyword">if</span> (choice == <span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data: "</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
        tree[<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>] = data;
        buildTree(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num - <span class="hljs-number">1</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Do you want to enter right child of %d? (1/0): "</span>, tree[index]);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;choice);
    <span class="hljs-keyword">if</span> (choice == <span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data: "</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
        tree[<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>] = data;
        buildTree(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num - <span class="hljs-number">1</span>);
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">display</span>(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, tree[index]);
    <span class="hljs-built_in">display</span>(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display_tree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> level)</span></span>{
    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (tree[index] == <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    
    display_tree(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num, level + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|\t"</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|------&gt;%d\n"</span>, tree[index]);
    display_tree(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num, level + <span class="hljs-number">1</span>);
}


<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> num;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter number of nodes: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;num);
    <span class="hljs-keyword">int</span> *tree = createTree(num);
    buildTree(tree, <span class="hljs-number">0</span>, num - <span class="hljs-number">1</span>);
    display_tree(tree, <span class="hljs-number">0</span>, num - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h3 id="binary-search-tree-implementation-using-linked-lists">Binary Search Tree implementation using Linked Lists</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
{</span>
    <span class="hljs-keyword">int</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">left</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">right</span>;</span>
};

<span class="hljs-function">struct Node * <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Node</span> *)<span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>));</span>
    newNode-&gt;data = data;
    newNode-&gt;left = <span class="hljs-literal">NULL</span>;
    newNode-&gt;right = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> newNode;
}

<span class="hljs-function">struct Node * <span class="hljs-title">bst_iter</span><span class="hljs-params">(struct Node ** root, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">int</span> data;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data: "</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> = <span class="hljs-title">getNode</span>(<span class="hljs-title">data</span>);</span>
        <span class="hljs-keyword">if</span>(*root == <span class="hljs-literal">NULL</span>){
            *root = newNode;
        }
        <span class="hljs-keyword">else</span>{
            struct Node *temp = *root;
            <span class="hljs-keyword">while</span>(temp != <span class="hljs-literal">NULL</span>){
                <span class="hljs-keyword">if</span>(data &lt; temp-&gt;data){
                    <span class="hljs-keyword">if</span>(temp-&gt;left == <span class="hljs-literal">NULL</span>){
                        temp-&gt;left = newNode;
                        <span class="hljs-keyword">break</span>;
                    }
                    <span class="hljs-keyword">else</span>{
                        temp = temp-&gt;left;
                    }
                }
                <span class="hljs-keyword">else</span>{
                    <span class="hljs-keyword">if</span>(temp-&gt;right == <span class="hljs-literal">NULL</span>){
                        temp-&gt;right = newNode;
                        <span class="hljs-keyword">break</span>;
                    }
                    <span class="hljs-keyword">else</span>{
                        temp = temp-&gt;right;
                    }
                }
            }
        }
    }    
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    inorder(root-&gt;left);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, root-&gt;data);
    inorder(root-&gt;right);    
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, root-&gt;data);
    preorder(root-&gt;left);
    preorder(root-&gt;right);    
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    postorder(root-&gt;left);
    postorder(root-&gt;right);    
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, root-&gt;data);
}

<span class="hljs-function">struct Node * <span class="hljs-title">search</span><span class="hljs-params">(struct Node * root, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> *child_side)</span></span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Not found\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;data == target) {
        *child_side = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> root;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;left-&gt;data == target) {
        *child_side = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> root;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root-&gt;right != <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right-&gt;data == target) {
        *child_side = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">return</span> root;
    }  
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; root-&gt;data) {
        <span class="hljs-keyword">return</span> search(root-&gt;left, target, child_side);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> search(root-&gt;right, target, child_side);
    }
}

<span class="hljs-function">struct Node * <span class="hljs-title">inorder_successor</span><span class="hljs-params">(struct Node *root, <span class="hljs-keyword">int</span> target)</span></span>{
    <span class="hljs-keyword">int</span> child_side;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">parent</span> = <span class="hljs-title">search</span>(<span class="hljs-title">root</span>, <span class="hljs-title">target</span>, &amp;<span class="hljs-title">child_side</span>);</span>
    <span class="hljs-keyword">if</span>(parent == <span class="hljs-literal">NULL</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Target not found in tree\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    }
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> = <span class="hljs-title">NULL</span>;</span>
    <span class="hljs-keyword">if</span> (child_side = <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">if</span> (parent -&gt; right != <span class="hljs-literal">NULL</span>)
        {
            temp = parent -&gt; right;
            <span class="hljs-keyword">while</span> (temp -&gt; left != <span class="hljs-literal">NULL</span>)
            {
                temp = temp -&gt; left;
            }
            <span class="hljs-keyword">return</span> temp;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No inorder successor\n"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        }        
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child_side = <span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">if</span> (parent -&gt; left -&gt; left == <span class="hljs-literal">NULL</span> &amp;&amp; parent -&gt; left -&gt; right == <span class="hljs-literal">NULL</span>)
        {
            <span class="hljs-keyword">return</span> parent;
        }
        <span class="hljs-keyword">if</span> (parent -&gt; right -&gt;right != <span class="hljs-literal">NULL</span>)
        {
            temp = parent -&gt; right -&gt; right;
            <span class="hljs-keyword">while</span> (temp -&gt; left != <span class="hljs-literal">NULL</span>)
            {
                temp = temp -&gt; left;
            }
            <span class="hljs-keyword">return</span> temp;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">return</span> parent;
        }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child_side = <span class="hljs-number">2</span>)
    {
        <span class="hljs-keyword">while</span> (child_side == <span class="hljs-number">2</span>)
        {
            parent = search(root, parent -&gt; data, &amp;child_side);
        }
        <span class="hljs-keyword">if</span> (child_side == <span class="hljs-number">1</span>)
        {
            <span class="hljs-keyword">return</span> parent;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No inorder successor\n"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        }
    }    
}

<span class="hljs-function">struct Node * <span class="hljs-title">inorder_predecessor</span><span class="hljs-params">(struct Node *root, <span class="hljs-keyword">int</span> target)</span></span>{
    <span class="hljs-keyword">int</span> child_side;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">parent</span> = <span class="hljs-title">search</span>(<span class="hljs-title">root</span>, <span class="hljs-title">target</span>, &amp;<span class="hljs-title">child_side</span>);</span>
    <span class="hljs-keyword">if</span>(parent == <span class="hljs-literal">NULL</span>){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Target not found in tree\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    }
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> = <span class="hljs-title">NULL</span>;</span>
    <span class="hljs-keyword">if</span> (child_side == <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">if</span> (parent -&gt; left != <span class="hljs-literal">NULL</span>)
        {
            temp = parent -&gt; left;
            <span class="hljs-keyword">while</span> (temp -&gt; right != <span class="hljs-literal">NULL</span>)
            {
                temp = temp -&gt; right;
            }
            <span class="hljs-keyword">return</span> temp;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No inorder predecessor\n"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        }        
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child_side == <span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">if</span> (parent -&gt; left -&gt;left != <span class="hljs-literal">NULL</span>)
        {
            temp = parent -&gt; left -&gt; left;
            <span class="hljs-keyword">while</span> (temp -&gt; right != <span class="hljs-literal">NULL</span>)
            {
                temp = temp -&gt; right;
            }
            <span class="hljs-keyword">return</span> temp;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">while</span> (child_side == <span class="hljs-number">1</span>)
            {
                parent = search(root, parent -&gt; data, &amp;child_side);
            }
            <span class="hljs-keyword">if</span> (child_side == <span class="hljs-number">2</span>)
            {
                <span class="hljs-keyword">return</span> parent;
            }
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"No inorder predecessor\n"</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
        }              
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (child_side == <span class="hljs-number">2</span>)
    {
        <span class="hljs-keyword">if</span> (parent -&gt; right -&gt;left != <span class="hljs-literal">NULL</span>)
        {
            temp = parent -&gt; right -&gt; left;
            <span class="hljs-keyword">while</span> (temp -&gt; right != <span class="hljs-literal">NULL</span>)
            {
                temp = temp -&gt; right;
            }
            <span class="hljs-keyword">return</span> temp;
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-keyword">return</span> parent;
        }
    }  
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">display</span>(root-&gt;left);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, root-&gt;data);
    <span class="hljs-built_in">display</span>(root-&gt;right);    
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display_tree</span><span class="hljs-params">(struct Node *root, <span class="hljs-keyword">int</span> level)</span></span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    display_tree(root-&gt;right, level + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|\t"</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|------&gt;%d\n"</span>, root-&gt;data);
    display_tree(root-&gt;left, level + <span class="hljs-number">1</span>);
}

<span class="hljs-function">struct Node * <span class="hljs-title">leftmostRsub</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    }
    <span class="hljs-keyword">if</span> (root-&gt;right == <span class="hljs-literal">NULL</span>)
    {
        root = root-&gt;right;
        <span class="hljs-keyword">while</span>(root-&gt;left != <span class="hljs-literal">NULL</span>){
            root = root-&gt;left;
        }
        <span class="hljs-keyword">return</span> root;
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(struct Node ** root, <span class="hljs-keyword">int</span> target)</span></span>{
    <span class="hljs-keyword">int</span> child_side;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">parent</span> = <span class="hljs-title">search</span>(*<span class="hljs-title">root</span>, <span class="hljs-title">target</span>, &amp;<span class="hljs-title">child_side</span>);</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">tn</span> = <span class="hljs-title">NULL</span>;</span>
    <span class="hljs-keyword">switch</span> (child_side){
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            tn = parent;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            tn = parent-&gt;left;
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            tn = parent-&gt;right;
            <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-comment">// no children</span>
    <span class="hljs-keyword">if</span> (tn -&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; tn-&gt;right == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-keyword">switch</span> (child_side)
        {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"root node deleted\n"</span>);
            *root = <span class="hljs-literal">NULL</span>;
            <span class="hljs-built_in">free</span>(tn);
            <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            parent-&gt;left = <span class="hljs-literal">NULL</span>;
            <span class="hljs-built_in">free</span>(tn);
            <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            parent-&gt;right = <span class="hljs-literal">NULL</span>;
            <span class="hljs-built_in">free</span>(tn);
            <span class="hljs-keyword">return</span>;
        }
    }
    <span class="hljs-comment">// only left child</span>
    <span class="hljs-keyword">if</span> (tn-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; tn-&gt;right == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"only left child\n"</span>);
        <span class="hljs-keyword">switch</span> (child_side)
        {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            *root = tn-&gt;left;
            <span class="hljs-built_in">free</span>(tn);
            <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            parent-&gt;left = tn-&gt;left;
            <span class="hljs-built_in">free</span>(tn);
            <span class="hljs-keyword">return</span>;
        
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            parent-&gt;right = tn-&gt;left;
            <span class="hljs-built_in">free</span>(tn);
            <span class="hljs-keyword">return</span>;
        }
    }
    <span class="hljs-comment">// only right child</span>
    <span class="hljs-keyword">if</span> (tn-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; tn-&gt;right != <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"only right child\n"</span>);
        <span class="hljs-keyword">switch</span> (child_side)
        {
        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
            *root = tn-&gt;right;
            <span class="hljs-built_in">free</span>(tn);
            <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
            parent-&gt;left = tn-&gt;right;
            <span class="hljs-built_in">free</span>(tn);
            <span class="hljs-keyword">return</span>;
        
        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
            parent-&gt;right = tn-&gt;right;
            <span class="hljs-built_in">free</span>(tn);
            <span class="hljs-keyword">return</span>;
        }
    }
    <span class="hljs-comment">// two children</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">successor</span> = <span class="hljs-title">leftmostRsub</span>(<span class="hljs-title">tn</span>);</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"successor: %d\n"</span>, successor-&gt;data);
    <span class="hljs-keyword">int</span> rData = successor-&gt;data;
    <span class="hljs-keyword">delete</span>(root, successor-&gt;data);
    tn-&gt;data = rData;
}

<span class="hljs-function">struct Node* <span class="hljs-title">minValueNode</span><span class="hljs-params">(struct Node* node)</span> </span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">current</span> = <span class="hljs-title">node</span>;</span>
  
    <span class="hljs-comment">/* loop down to find the leftmost leaf */</span>
    <span class="hljs-keyword">while</span> (current &amp;&amp; current-&gt;left != <span class="hljs-literal">NULL</span>)
        current = current-&gt;left;
  
    <span class="hljs-keyword">return</span> current;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">root</span> = <span class="hljs-title">NULL</span>;</span>
    <span class="hljs-keyword">int</span> num;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter number of nodes: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;num);
    bst_iter(&amp;root, num);
    display_tree(root, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter element to search: "</span>);
    <span class="hljs-keyword">int</span> target;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;target);
    <span class="hljs-keyword">int</span> child_side;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">parent</span> = <span class="hljs-title">search</span>(<span class="hljs-title">root</span>, <span class="hljs-title">target</span>, &amp;<span class="hljs-title">child_side</span>);</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Parent: %d\n"</span>, parent-&gt;data);
    <span class="hljs-keyword">switch</span> (child_side)
    {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"this node is the target node\n"</span>);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Left child\n"</span>);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Right child\n"</span>);
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">delete</span>(&amp;root, target);
    display_tree(root, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

</div></code></pre>
<hr>
<h3 id="binary-search-tree-implementation-using-arrays">Binary Search Tree implementation using Arrays</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">index_check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span> ((index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>) || (index &lt; <span class="hljs-number">0</span>))
    {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_child</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * index) + <span class="hljs-number">1</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right_child</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * index) + <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">return</span> (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">bst_iter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">int</span> *tree = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">calloc</span>((<span class="hljs-keyword">int</span>)((<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, (<span class="hljs-keyword">double</span>)(num))) - <span class="hljs-number">1</span>), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++){
        <span class="hljs-keyword">int</span> data;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data: "</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(tree[index] != <span class="hljs-number">0</span>){
            <span class="hljs-keyword">if</span>(data &lt; tree[index]){
                index = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">else</span>{
                index = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;
            }
        }
        tree[index] = data;
    }
    <span class="hljs-keyword">return</span> tree;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">display</span>(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, tree[index]);
    <span class="hljs-built_in">display</span>(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display_tree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> level)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span>(tree[index] == <span class="hljs-number">0</span>){
        <span class="hljs-keyword">return</span>;
    }
    display_tree(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num, level + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i++){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|\t"</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|------&gt;%d\n"</span>, tree[index]);
    display_tree(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num, level + <span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (tree[index] == <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">return</span>;
    }    
    inorder(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, tree[index]);
    inorder(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (tree[index] == <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, tree[index]);
    preorder(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num);
    preorder(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (tree[index] == <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    postorder(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num);
    postorder(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, tree[index]);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> value, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (index_check(index, num))
    {
        <span class="hljs-keyword">if</span> (value == tree[index])
        {
            <span class="hljs-keyword">return</span> index;
        }        
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value &lt; tree[index])
        {
            index = left_child(index);
        }
        <span class="hljs-keyword">else</span> {
            index = right_child(index);
        }        
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inorder_successor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">int</span> index = search(tree, target, num);
    <span class="hljs-keyword">if</span> (index == <span class="hljs-number">-1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Target not found in tree\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    <span class="hljs-keyword">if</span> (tree[right_child(index)] != <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">int</span> successor = right_child(index);
        <span class="hljs-keyword">while</span> (tree[left_child(successor)] != <span class="hljs-number">0</span>)
        {
            successor = left_child(successor);
        }
        <span class="hljs-keyword">return</span> successor;
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">int</span> successor = parent(index);
        <span class="hljs-keyword">while</span> (tree[successor] &lt; tree[index])
        {
            successor = parent(successor);
        }
        <span class="hljs-keyword">return</span> successor;
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">int</span> index = search(tree, target, num);
    <span class="hljs-keyword">if</span> (index == <span class="hljs-number">-1</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Target not found in tree\n"</span>);
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// no children</span>
    <span class="hljs-keyword">if</span> (tree[left_child(index)] == <span class="hljs-number">0</span> &amp;&amp; tree[right_child(index)] == <span class="hljs-number">0</span>)
    {
        tree[index] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// only left child</span>
    <span class="hljs-keyword">if</span> (tree[left_child(index)] != <span class="hljs-number">0</span> &amp;&amp; tree[right_child(index)] == <span class="hljs-number">0</span>)
    {
        tree[index] = tree[left_child(index)];
        tree[left_child(index)] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// only right child</span>
    <span class="hljs-keyword">if</span> (tree[left_child(index)] == <span class="hljs-number">0</span> &amp;&amp; tree[right_child(index)] != <span class="hljs-number">0</span>)
    {
        tree[index] = tree[right_child(index)];
        tree[right_child(index)] = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-comment">// two children</span>
    <span class="hljs-keyword">int</span> successor = right_child(index);
    <span class="hljs-keyword">while</span> (tree[left_child(successor)] != <span class="hljs-number">0</span>)
    {
        successor = left_child(successor);
    }
    tree[index] = tree[successor];
    tree[successor] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> num;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter number of nodes: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;num);
    <span class="hljs-keyword">int</span> *tree = bst_iter(num);
    <span class="hljs-built_in">display</span>(tree, <span class="hljs-number">0</span>, num);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n--------------------\n"</span>);
    display_tree(tree, <span class="hljs-number">0</span>, num, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n--------------------\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Inorder: "</span>);
    inorder(tree, <span class="hljs-number">0</span>, num);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n--------------------\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Preorder: "</span>);
    preorder(tree, <span class="hljs-number">0</span>, num);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n--------------------\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Postorder: "</span>);
    postorder(tree, <span class="hljs-number">0</span>, num);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n--------------------\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"enter target value: "</span>);
    <span class="hljs-keyword">int</span> target;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;target);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, search(tree, target, num));
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h3 id="same-tree---100--easy">Same Tree - 100 | <code>Easy</code></h3>
<h4 id="problem-statement">Problem Statement</h4>
<p>Given the roots of two binary trees p and q, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>
<h4 id="solution">Solution</h4>
<pre class="hljs"><code><div><span class="hljs-comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">symRec</span><span class="hljs-params">(struct TreeNode* left, struct TreeNode* right)</span></span>{
    <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">NULL</span> || right == <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">if</span>(left-&gt;val != right-&gt;val){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    
    <span class="hljs-keyword">if</span>(left-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; right-&gt;left != <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">if</span>(symRec(left-&gt;left, right-&gt;left) == <span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left-&gt;left != <span class="hljs-literal">NULL</span> || right-&gt;left != <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">if</span>(left-&gt;right != <span class="hljs-literal">NULL</span> &amp;&amp; right-&gt;right != <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">if</span>(symRec(left-&gt;right, right-&gt;right) == <span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left-&gt;right != <span class="hljs-literal">NULL</span> || right-&gt;right != <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(struct TreeNode* p, struct TreeNode* q)</span> </span>{
    <span class="hljs-keyword">if</span>(p == <span class="hljs-literal">NULL</span> &amp;&amp; q == <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> symRec(p, q);
}
</div></code></pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(n)</li>
</ul>
<h4 id="runtime-stats">Runtime Stats</h4>
<ul>
<li>Runtime: <code>0 ms</code>, faster than <code>100.00%</code> of C online submissions for Same Tree.</li>
<li>Memory Usage: <code>6.38 MB</code>, less than <code>93.56%</code> of C online submissions for Same Tree.</li>
</ul>
<hr>
<h3 id="symmetric-tree---101--easy">Symmetric Tree - 101 | <code>Easy</code></h3>
<h4 id="problem-statement">Problem Statement</h4>
<p>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p>
<h4 id="solution">Solution</h4>
<pre class="hljs"><code><div><span class="hljs-comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">symRec</span><span class="hljs-params">(struct TreeNode* left, struct TreeNode* right)</span></span>{
    <span class="hljs-keyword">if</span>(left == <span class="hljs-literal">NULL</span> || right == <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">if</span>(left-&gt;val != right-&gt;val){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    
    <span class="hljs-keyword">if</span>(left-&gt;left != <span class="hljs-literal">NULL</span> &amp;&amp; right-&gt;right != <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">if</span>(symRec(left-&gt;left, right-&gt;right) == <span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left-&gt;left != <span class="hljs-literal">NULL</span> || right-&gt;right != <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">if</span>(left-&gt;right != <span class="hljs-literal">NULL</span> &amp;&amp; right-&gt;left != <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">if</span>(symRec(left-&gt;right, right-&gt;left) == <span class="hljs-number">0</span>){
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left-&gt;right != <span class="hljs-literal">NULL</span> || right-&gt;left != <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(struct TreeNode* root)</span> </span>{
    <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> symRec(root-&gt;left, root-&gt;right);
}
</div></code></pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(n)</li>
</ul>
<h4 id="runtime-stats">Runtime Stats</h4>
<ul>
<li>Runtime: <code>0 ms</code>, faster than <code>100.00%</code> of C online submissions for Symmetric Tree.</li>
<li>Memory Usage: <code>7.69 MB</code>, less than <code>29.83%</code> of C online submissions for Symmetric Tree.</li>
</ul>
<hr>
<h3 id="lowest-common-ancestor-of-a-binary-search-tree---235--medium">Lowest Common Ancestor of a Binary Search Tree - 235 | <code>Medium</code></h3>
<h4 id="problem-statement">Problem Statement</h4>
<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.</p>
<p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</p>
<h4 id="solution">Solution</h4>
<pre class="hljs"><code><div><span class="hljs-comment">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */</span>


<span class="hljs-function">struct TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q)</span> </span>{
    <span class="hljs-keyword">if</span>(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val){
        <span class="hljs-keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);}
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val){
        <span class="hljs-keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> root;
    }  
}
</div></code></pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<ul>
<li>Time Complexity: O(n)</li>
<li>Space Complexity: O(n)</li>
</ul>
<h4 id="runtime-stats">Runtime Stats</h4>
<ul>
<li>Runtime: <code>36 ms</code>, faster than <code>7.33%</code> of C online submissions for Lowest Common Ancestor of a Binary Search Tree.</li>
<li>Memory Usage: <code>27.6 MB</code>, less than <code>36.07%</code> of C online submissions for Lowest Common Ancestor of a Binary Search Tree.</li>
</ul>
<hr>
<h2 id="avl-trees-and-expression-trees">AVL trees and expression trees</h2>
<h3 id="avl-tree-implementation-using-linked-lists">AVL tree implementation using Linked Lists</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
{</span>
    <span class="hljs-keyword">int</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">left</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">right</span>;</span>
};

<span class="hljs-function">struct Node * <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Node</span> *)<span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>));</span>
    newNode-&gt;data = data;
    newNode-&gt;left = <span class="hljs-literal">NULL</span>;
    newNode-&gt;right = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> newNode;
}

<span class="hljs-function">struct Node * <span class="hljs-title">bst_iter</span><span class="hljs-params">(struct Node ** root, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">int</span> data;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data: "</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> = <span class="hljs-title">getNode</span>(<span class="hljs-title">data</span>);</span>
        <span class="hljs-keyword">if</span>(*root == <span class="hljs-literal">NULL</span>){
            *root = newNode;
        }
        <span class="hljs-keyword">else</span>{
            struct Node *temp = *root;
            <span class="hljs-keyword">while</span>(temp != <span class="hljs-literal">NULL</span>){
                <span class="hljs-keyword">if</span>(data &lt; temp-&gt;data){
                    <span class="hljs-keyword">if</span>(temp-&gt;left == <span class="hljs-literal">NULL</span>){
                        temp-&gt;left = newNode;
                        <span class="hljs-keyword">break</span>;
                    }
                    <span class="hljs-keyword">else</span>{
                        temp = temp-&gt;left;
                    }
                }
                <span class="hljs-keyword">else</span>{
                    <span class="hljs-keyword">if</span>(temp-&gt;right == <span class="hljs-literal">NULL</span>){
                        temp-&gt;right = newNode;
                        <span class="hljs-keyword">break</span>;
                    }
                    <span class="hljs-keyword">else</span>{
                        temp = temp-&gt;right;
                    }
                }
            }
        }
    }    
}

<span class="hljs-function">struct Node * <span class="hljs-title">search</span><span class="hljs-params">(struct Node * root, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> *child_side)</span></span>{
    <span class="hljs-keyword">if</span> (root -&gt; data == target)
    {
        *child_side = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> root;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root -&gt; left -&gt; data == target)
    {
        *child_side = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">return</span> root;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root -&gt; right -&gt; data == target)
    {
        *child_side = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">return</span> root;
    }  
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; root -&gt; data)
    {
        search(root-&gt;left, target, child_side);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; root -&gt; data)
    {
        search(root-&gt;right, target, child_side);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Not found\n"</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display_tree</span><span class="hljs-params">(struct Node *root, <span class="hljs-keyword">int</span> level)</span></span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    display_tree(root-&gt;right, level + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|\t"</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|------&gt;%d\n"</span>, root-&gt;data);
    display_tree(root-&gt;left, level + <span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bst_insert</span><span class="hljs-params">(struct Node **root, <span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> = <span class="hljs-title">getNode</span>(<span class="hljs-title">data</span>);</span>
    <span class="hljs-keyword">if</span>(*root == <span class="hljs-literal">NULL</span>){
        *root = newNode;
    }
    <span class="hljs-keyword">else</span>{
        struct Node *temp = *root;
        <span class="hljs-keyword">while</span>(temp != <span class="hljs-literal">NULL</span>){
            <span class="hljs-keyword">if</span>(data &lt; temp-&gt;data){
                <span class="hljs-keyword">if</span>(temp-&gt;left == <span class="hljs-literal">NULL</span>){
                    temp-&gt;left = newNode;
                    <span class="hljs-keyword">break</span>;
                }
                <span class="hljs-keyword">else</span>{
                    temp = temp-&gt;left;
                }
            }
            <span class="hljs-keyword">else</span>{
                <span class="hljs-keyword">if</span>(temp-&gt;right == <span class="hljs-literal">NULL</span>){
                    temp-&gt;right = newNode;
                    <span class="hljs-keyword">break</span>;
                }
                <span class="hljs-keyword">else</span>{
                    temp = temp-&gt;right;
                }
            }
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">int</span> left_height = <span class="hljs-built_in">height</span>(root-&gt;left);
        <span class="hljs-keyword">int</span> right_height = <span class="hljs-built_in">height</span>(root-&gt;right);
        <span class="hljs-keyword">if</span>(left_height &gt; right_height){
            <span class="hljs-keyword">return</span> left_height + <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">return</span> right_height + <span class="hljs-number">1</span>;
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">balance_factor</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">int</span> left_height = <span class="hljs-built_in">height</span>(root-&gt;left);
        <span class="hljs-keyword">int</span> right_height = <span class="hljs-built_in">height</span>(root-&gt;right);
        <span class="hljs-keyword">return</span> left_height - right_height;
    }
}

<span class="hljs-function">struct Node * <span class="hljs-title">left_rotate</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newRoot</span> = <span class="hljs-title">root</span>-&gt;<span class="hljs-title">right</span>;</span>
    root-&gt;right = newRoot-&gt;left;
    newRoot-&gt;left = root;
    <span class="hljs-keyword">return</span> newRoot;
}

<span class="hljs-function">struct Node * <span class="hljs-title">right_rotate</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newRoot</span> = <span class="hljs-title">root</span>-&gt;<span class="hljs-title">left</span>;</span>
    root-&gt;left = newRoot-&gt;right;
    newRoot-&gt;right = root;
    <span class="hljs-keyword">return</span> newRoot;
}

<span class="hljs-function">struct Node * <span class="hljs-title">left_right_rotate</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newRoot</span> = <span class="hljs-title">root</span>-&gt;<span class="hljs-title">left</span>;</span>
    root-&gt;left = left_rotate(newRoot);
    <span class="hljs-keyword">return</span> right_rotate(root);
}

<span class="hljs-function">struct Node * <span class="hljs-title">right_left_rotate</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newRoot</span> = <span class="hljs-title">root</span>-&gt;<span class="hljs-title">right</span>;</span>
    root-&gt;right = right_rotate(newRoot);
    <span class="hljs-keyword">return</span> left_rotate(root);
}

<span class="hljs-function">struct Node * <span class="hljs-title">balance</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    }
    <span class="hljs-keyword">else</span>{
        root-&gt;left = balance(root-&gt;left);
        root-&gt;right = balance(root-&gt;right);
        <span class="hljs-keyword">int</span> bf = balance_factor(root);
        <span class="hljs-keyword">if</span>(bf &gt; <span class="hljs-number">1</span>){
            <span class="hljs-keyword">if</span>(balance_factor(root-&gt;left) &gt; <span class="hljs-number">0</span>){
                root = right_rotate(root);
            }
            <span class="hljs-keyword">else</span>{
                root = left_right_rotate(root);
            }
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bf &lt; <span class="hljs-number">-1</span>){
            <span class="hljs-keyword">if</span>(balance_factor(root-&gt;right) &lt; <span class="hljs-number">0</span>){
                root = left_rotate(root);
            }
            <span class="hljs-keyword">else</span>{
                root = right_left_rotate(root);
            }
        }
        <span class="hljs-keyword">return</span> root;
    }
}

<span class="hljs-function">struct Node * <span class="hljs-title">bst_delete</span><span class="hljs-params">(struct Node *root, <span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">if</span>(data &lt; root-&gt;data){
            root-&gt;left = bst_delete(root-&gt;left, data);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data &gt; root-&gt;data){
            root-&gt;right = bst_delete(root-&gt;right, data);
        }
        <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>){
                <span class="hljs-built_in">free</span>(root);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span>){
                struct Node *temp = root-&gt;right;
                <span class="hljs-built_in">free</span>(root);
                <span class="hljs-keyword">return</span> temp;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;right == <span class="hljs-literal">NULL</span>){
                struct Node *temp = root-&gt;left;
                <span class="hljs-built_in">free</span>(root);
                <span class="hljs-keyword">return</span> temp;
            }
            <span class="hljs-keyword">else</span>{
                struct Node *temp = root-&gt;right;
                <span class="hljs-keyword">while</span>(temp-&gt;left != <span class="hljs-literal">NULL</span>){
                    temp = temp-&gt;left;
                }
                root-&gt;data = temp-&gt;data;
                root-&gt;right = bst_delete(root-&gt;right, temp-&gt;data);
            }
        }
        root = balance(root);
        <span class="hljs-keyword">return</span> root;
    }
}

<span class="hljs-comment">// avl insert</span>
<span class="hljs-function">struct Node * <span class="hljs-title">avl_insert</span><span class="hljs-params">(struct Node *root, <span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>){
        root = getNode(data);
        <span class="hljs-keyword">return</span> root;
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">if</span>(data &lt; root-&gt;data){
            root-&gt;left = avl_insert(root-&gt;left, data);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data &gt; root-&gt;data){
            root-&gt;right = avl_insert(root-&gt;right, data);
        }
        <span class="hljs-keyword">else</span>{
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Duplicate data!\n"</span>);
            <span class="hljs-keyword">return</span> root;
        }
        root = balance(root);
        <span class="hljs-keyword">return</span> root;
    }
}

<span class="hljs-comment">// avl delete</span>
<span class="hljs-function">struct Node * <span class="hljs-title">avl_delete</span><span class="hljs-params">(struct Node *root, <span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">if</span>(data &lt; root-&gt;data){
            root-&gt;left = avl_delete(root-&gt;left, data);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(data &gt; root-&gt;data){
            root-&gt;right = avl_delete(root-&gt;right, data);
        }
        <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span> &amp;&amp; root-&gt;right == <span class="hljs-literal">NULL</span>){
                <span class="hljs-built_in">free</span>(root);
                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;left == <span class="hljs-literal">NULL</span>){
                struct Node *temp = root-&gt;right;
                <span class="hljs-built_in">free</span>(root);
                <span class="hljs-keyword">return</span> temp;
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;right == <span class="hljs-literal">NULL</span>){
                struct Node *temp = root-&gt;left;
                <span class="hljs-built_in">free</span>(root);
                <span class="hljs-keyword">return</span> temp;
            }
            <span class="hljs-keyword">else</span>{
                struct Node *temp = root-&gt;right;
                <span class="hljs-keyword">while</span>(temp-&gt;left != <span class="hljs-literal">NULL</span>){
                    temp = temp-&gt;left;
                }
                root-&gt;data = temp-&gt;data;
                root-&gt;right = avl_delete(root-&gt;right, temp-&gt;data);
            }
        }
        root = balance(root);
        <span class="hljs-keyword">return</span> root;
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">root</span> = <span class="hljs-title">NULL</span>;</span>
    <span class="hljs-keyword">int</span> num, data, target, child_side;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter number of nodes: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;num);
    bst_iter(&amp;root, num);
    display_tree(root, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data to insert: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
    bst_insert(&amp;root, data);
    display_tree(root, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data to delete: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
    root = bst_delete(root, data);
    display_tree(root, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data to search: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;target);
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">parent</span> = <span class="hljs-title">search</span>(<span class="hljs-title">root</span>, <span class="hljs-title">target</span>, &amp;<span class="hljs-title">child_side</span>);</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Parent: %d\n"</span>, parent-&gt;data);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Child side: %d\n"</span>, child_side);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Height: %d\n"</span>, <span class="hljs-built_in">height</span>(root));
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h3 id="avl-tree-implementation-using-arrays">AVL tree implementation using Arrays</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">index_check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span> ((index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>) || (index &lt; <span class="hljs-number">0</span>))
    {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_child</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * index) + <span class="hljs-number">1</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right_child</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * index) + <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">return</span> (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">bst_iter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">int</span> *tree = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">calloc</span>((<span class="hljs-keyword">int</span>)((<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, (<span class="hljs-keyword">double</span>)(num))) - <span class="hljs-number">1</span>), <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++){
        <span class="hljs-keyword">int</span> data;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data: "</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(tree[index] != <span class="hljs-number">0</span>){
            <span class="hljs-keyword">if</span>(data &lt; tree[index]){
                index = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">else</span>{
                index = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;
            }
        }
        tree[index] = data;
    }
    <span class="hljs-keyword">return</span> tree;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bst_insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(tree[index] != <span class="hljs-number">0</span>){
        <span class="hljs-keyword">if</span>(data &lt; tree[index]){
            index = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span>{
            index = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;
        }
    }
    tree[index] = data;
    <span class="hljs-keyword">return</span> index;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bst_search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> data)</span></span>{
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(tree[index] != data){
        <span class="hljs-keyword">if</span>(data &lt; tree[index]){
            index = <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">else</span>{
            index = <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;
        }
    }
    <span class="hljs-keyword">return</span> index;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">height</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">height</span>(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num);
    <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">height</span>(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num);
    <span class="hljs-keyword">if</span>(left &gt; right){
        <span class="hljs-keyword">return</span> left + <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> right + <span class="hljs-number">1</span>;
    }
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">balance_factor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">int</span> left = <span class="hljs-built_in">height</span>(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num);
    <span class="hljs-keyword">int</span> right = <span class="hljs-built_in">height</span>(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num);
    <span class="hljs-keyword">return</span> left - right;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate_right</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">int</span> temp = tree[index];
    tree[index] = tree[<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>];
    tree[<span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>] = temp;
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate_left</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">int</span> temp = tree[index];
    tree[index] = tree[<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>];
    tree[<span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>] = temp;
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate_left_right</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span>;
    }
    rotate_left(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num);
    rotate_right(tree, index, num);
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate_right_left</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span>;
    }
    rotate_right(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num);
    rotate_left(tree, index, num);
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">balance</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span>;
    }
    balance(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num);
    balance(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num);
    <span class="hljs-keyword">int</span> bf = balance_factor(tree, index, num);
    <span class="hljs-keyword">if</span>(bf &gt; <span class="hljs-number">1</span>){
        <span class="hljs-keyword">if</span>(balance_factor(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num) &gt; <span class="hljs-number">0</span>){
            rotate_right(tree, index, num);
        }
        <span class="hljs-keyword">else</span>{
            rotate_left_right(tree, index, num);
        }
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bf &lt; <span class="hljs-number">-1</span>){
        <span class="hljs-keyword">if</span>(balance_factor(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num) &lt; <span class="hljs-number">0</span>){
            rotate_left(tree, index, num);
        }
        <span class="hljs-keyword">else</span>{
            rotate_right_left(tree, index, num);
        }
    }
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">avl_insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> data, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">int</span> index = bst_insert(tree, data);
    balance(tree, index, num);
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">avl_delete</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> data, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">int</span> index = bst_search(tree, data);
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span>(tree[left_child(index)] == <span class="hljs-number">0</span> &amp;&amp; tree[right_child(index)] == <span class="hljs-number">0</span>){
        tree[index] = <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tree[left_child(index)] == <span class="hljs-number">0</span>){
        tree[index] = tree[right_child(index)];
        tree[right_child(index)] = <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tree[right_child(index)] == <span class="hljs-number">0</span>){
        tree[index] = tree[left_child(index)];
        tree[left_child(index)] = <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">int</span> temp = tree[right_child(index)];
        <span class="hljs-keyword">while</span>(tree[left_child(temp)] != <span class="hljs-number">0</span>){
            temp = tree[left_child(temp)];
        }
        tree[index] = tree[temp];
        tree[temp] = <span class="hljs-number">0</span>;
    }
    balance(tree, index, num);
    <span class="hljs-keyword">return</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">display</span>(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, tree[index]);
    <span class="hljs-built_in">display</span>(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display_tree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> level)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span>(tree[index] == <span class="hljs-number">0</span>){
        <span class="hljs-keyword">return</span>;
    }
    display_tree(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num, level + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i++){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|\t"</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|------&gt;%d\n"</span>, tree[index]);
    display_tree(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num, level + <span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> num;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter number of nodes: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;num);
    <span class="hljs-keyword">int</span> *tree = bst_iter(num);
    <span class="hljs-built_in">display</span>(tree, <span class="hljs-number">0</span>, num);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    display_tree(tree, <span class="hljs-number">0</span>, num, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    <span class="hljs-keyword">int</span> data;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data to insert: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
    avl_insert(tree, data, num);
    <span class="hljs-built_in">display</span>(tree, <span class="hljs-number">0</span>, num);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    display_tree(tree, <span class="hljs-number">0</span>, num, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data to delete: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
    avl_delete(tree, data, num);
    <span class="hljs-built_in">display</span>(tree, <span class="hljs-number">0</span>, num);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    display_tree(tree, <span class="hljs-number">0</span>, num, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<hr>
<h3 id="expression-tree-insertion-using-linked-lists">Expression tree insertion using Linked Lists</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
{</span>
    <span class="hljs-keyword">char</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">left</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">right</span>;</span>
};

<span class="hljs-function">struct Node * <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">char</span> data)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Node</span> *)<span class="hljs-title">malloc</span>(<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>));</span>
    newNode-&gt;data = data;
    newNode-&gt;left = <span class="hljs-literal">NULL</span>;
    newNode-&gt;right = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> newNode;
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">stack</span>[100];</span>
<span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(struct Node *node)</span></span>{
    <span class="hljs-built_in">stack</span>[++top] = node;
}

<span class="hljs-function">struct Node * <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>[top--];
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isOperator</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>{
    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span> || c == <span class="hljs-string">'*'</span> || c == <span class="hljs-string">'/'</span> || c == <span class="hljs-string">'^'</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span>;
    }
    inorder(root-&gt;left);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c "</span>, root-&gt;data);
    inorder(root-&gt;right);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">preorder</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c "</span>, root-&gt;data);
    preorder(root-&gt;left);
    preorder(root-&gt;right);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span>;
    }
    postorder(root-&gt;left);
    postorder(root-&gt;right);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c "</span>, root-&gt;data);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display_tree</span><span class="hljs-params">(struct Node *root, <span class="hljs-keyword">int</span> level)</span></span>{
    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    display_tree(root-&gt;right, level + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|\t"</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|------&gt;%c\n"</span>, root-&gt;data);
    display_tree(root-&gt;left, level + <span class="hljs-number">1</span>);
}

<span class="hljs-function">struct Node * <span class="hljs-title">expression_tree</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *postfix)</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(postfix); i++){
        <span class="hljs-keyword">if</span>(isOperator(postfix[i])){
            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> = <span class="hljs-title">getNode</span>(<span class="hljs-title">postfix</span>[<span class="hljs-title">i</span>]);</span>
            newNode-&gt;right = pop();
            newNode-&gt;left = pop();
            push(newNode);
        }
        <span class="hljs-keyword">else</span>{
            struct Node *newNode = getNode(postfix[i]);
            push(newNode);
        }
    }
    <span class="hljs-keyword">return</span> pop();
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">evaluate</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">if</span>(isOperator(root-&gt;data)){
        <span class="hljs-keyword">switch</span> (root-&gt;data)
        {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:
            <span class="hljs-keyword">return</span> evaluate(root-&gt;left) + evaluate(root-&gt;right);
        <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:
            <span class="hljs-keyword">return</span> evaluate(root-&gt;left) - evaluate(root-&gt;right);
        <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:
            <span class="hljs-keyword">return</span> evaluate(root-&gt;left) * evaluate(root-&gt;right);
        <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:
            <span class="hljs-keyword">return</span> evaluate(root-&gt;left) / evaluate(root-&gt;right);
        <span class="hljs-keyword">case</span> <span class="hljs-string">'^'</span>:
            <span class="hljs-keyword">return</span> evaluate(root-&gt;left) ^ evaluate(root-&gt;right);
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> root-&gt;data - <span class="hljs-string">'0'</span>;
    }
}
</div></code></pre>
<hr>
<h3 id="expression-tree-insertion-using-arrays">Expression tree insertion using Arrays</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">index_check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span> ((index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>) || (index &lt; <span class="hljs-number">0</span>))
    {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_child</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * index) + <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right_child</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * index) + <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">return</span> (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display_tree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> level)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span>(tree[index] == <span class="hljs-number">0</span>){
        <span class="hljs-keyword">return</span>;
    }
    display_tree(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, num, level + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i++){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|\t"</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|------&gt;%d\n"</span>, tree[index]);
    display_tree(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, num, level + <span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isOperator</span><span class="hljs-params">(<span class="hljs-keyword">char</span> c)</span></span>{
    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">'+'</span> || c == <span class="hljs-string">'-'</span> || c == <span class="hljs-string">'*'</span> || c == <span class="hljs-string">'/'</span> || c == <span class="hljs-string">'^'</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> * <span class="hljs-title">stack</span>[100];</span>
<span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(struct Node *node)</span></span>{
    <span class="hljs-built_in">stack</span>[++top] = node;
}

<span class="hljs-function">struct Node * <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">stack</span>[top--];
}

<span class="hljs-function">struct Node * <span class="hljs-title">expression_tree</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *postfix)</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(postfix); i++){
        <span class="hljs-keyword">if</span>(isOperator(postfix[i])){
            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> = <span class="hljs-title">getNode</span>(<span class="hljs-title">postfix</span>[<span class="hljs-title">i</span>]);</span>
            newNode-&gt;right = pop();
            newNode-&gt;left = pop();
            push(newNode);
        }
        <span class="hljs-keyword">else</span>{
            struct Node *newNode = getNode(postfix[i]);
            push(newNode);
        }
    }
    <span class="hljs-keyword">return</span> pop();
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">evaluate</span><span class="hljs-params">(struct Node *root)</span></span>{
    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">if</span>(isOperator(root-&gt;data)){
        <span class="hljs-keyword">switch</span> (root-&gt;data)
        {
        <span class="hljs-keyword">case</span> <span class="hljs-string">'+'</span>:
            <span class="hljs-keyword">return</span> evaluate(root-&gt;left) + evaluate(root-&gt;right);
        <span class="hljs-keyword">case</span> <span class="hljs-string">'-'</span>:
            <span class="hljs-keyword">return</span> evaluate(root-&gt;left) - evaluate(root-&gt;right);
        <span class="hljs-keyword">case</span> <span class="hljs-string">'*'</span>:
            <span class="hljs-keyword">return</span> evaluate(root-&gt;left) * evaluate(root-&gt;right);
        <span class="hljs-keyword">case</span> <span class="hljs-string">'/'</span>:
            <span class="hljs-keyword">return</span> evaluate(root-&gt;left) / evaluate(root-&gt;right);
        <span class="hljs-keyword">case</span> <span class="hljs-string">'^'</span>:
            <span class="hljs-keyword">return</span> evaluate(root-&gt;left) ^ evaluate(root-&gt;right);
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> root-&gt;data - <span class="hljs-string">'0'</span>;
    }
}
</div></code></pre>
<hr>
<h2 id="heaps">Heaps</h2>
<h3 id="min-heap-implementation-using-arrays">Min Heap implementation using Arrays</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;math.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Heap</span>{</span>
    <span class="hljs-keyword">int</span>* arr;
    <span class="hljs-keyword">int</span> last, <span class="hljs-built_in">size</span>;
};

<span class="hljs-function">struct Heap* <span class="hljs-title">createHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Heap</span> *<span class="hljs-title">heap</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Heap</span>*) <span class="hljs-title">malloc</span> (<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Heap</span>));</span>
    heap-&gt;arr = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">calloc</span> (<span class="hljs-built_in">size</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    heap-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-built_in">size</span>;
    heap-&gt;last = <span class="hljs-number">-1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">index_check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span> ((index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>) || (index &lt; <span class="hljs-number">0</span>))
    {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_child</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * index) + <span class="hljs-number">1</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right_child</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * index) + <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">return</span> (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">percolate_up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (arr[parent(index)] &gt; arr[index])
    {
        <span class="hljs-keyword">int</span> temp = arr[parent(index)];
        arr[parent(index)] = arr[index];
        arr[index] = temp;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span>;
    }    
    percolate_up(arr, parent(index));
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">percolate_down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> last)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt; last){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (arr[index] &lt; arr[left_child(index)] &amp;&amp; arr[index] &lt; arr[right_child(index)])
    {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (arr[left_child(index)] &lt; arr[right_child(index)])
    {
        <span class="hljs-comment">// left child is smaller</span>
        <span class="hljs-keyword">if</span> (arr[index] &gt; arr[left_child(index)])
        {
            <span class="hljs-keyword">int</span> temp = arr[index];
            arr[index] = arr[left_child(index)];
            arr[left_child(index)] = temp;
            percolate_down(arr, left_child(index), last);
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (arr[index] &gt; arr[right_child(index)])
        {
            <span class="hljs-keyword">int</span> temp = arr[index];
            arr[index] = arr[right_child(index)];
            arr[right_child(index)] = temp;
            percolate_down(arr, right_child(index), last);
        }
    }
    
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(struct Heap *h, <span class="hljs-keyword">int</span> val)</span> </span>{
    <span class="hljs-keyword">if</span> (h-&gt;last + <span class="hljs-number">1</span> &gt;= h-&gt;<span class="hljs-built_in">size</span>) {
        h-&gt;<span class="hljs-built_in">size</span>++;
        h-&gt;arr = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">realloc</span>(h-&gt;arr, h-&gt;<span class="hljs-built_in">size</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h-&gt;last + <span class="hljs-number">1</span>; i &lt; h-&gt;<span class="hljs-built_in">size</span>; ++i) {
            h-&gt;arr[i] = <span class="hljs-number">0</span>;  
        }
    }
    h-&gt;last++;
    h-&gt;arr[h-&gt;last] = val;
    percolate_up(h-&gt;arr, h-&gt;last);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete_min</span><span class="hljs-params">(struct Heap *h)</span></span>{
    h-&gt;arr[<span class="hljs-number">0</span>] = h-&gt;arr[h-&gt;last];
    <span class="hljs-comment">// h-&gt;arr[h-&gt;last] = 0;</span>
    h-&gt;last--;
    h-&gt;<span class="hljs-built_in">size</span>--;
    percolate_down(h-&gt;arr, <span class="hljs-number">0</span>, h-&gt;last);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display_tree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">int</span> level)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt; <span class="hljs-built_in">size</span>){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span>(tree[index] == <span class="hljs-number">0</span>){
        <span class="hljs-keyword">return</span>;
    }
    
    display_tree(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, <span class="hljs-built_in">size</span>, level + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i++){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|\t"</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|------&gt;%d\n"</span>, tree[index]);
    display_tree(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, <span class="hljs-built_in">size</span>, level + <span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> n, data;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter number of elements: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Heap</span> *<span class="hljs-title">heap</span> = <span class="hljs-title">createHeap</span>(<span class="hljs-title">n</span>);</span>
    heap-&gt;<span class="hljs-built_in">size</span> = n;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data: "</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
        insert(heap, data);
    }
    display_tree(heap-&gt;arr, <span class="hljs-number">0</span>, heap-&gt;<span class="hljs-built_in">size</span>, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"____________________________________\n\n"</span>);
    delete_min(heap);
    display_tree(heap-&gt;arr, <span class="hljs-number">0</span>, heap-&gt;<span class="hljs-built_in">size</span>, <span class="hljs-number">0</span>);
}
</div></code></pre>
<hr>
<h3 id="max-heap-implementation-using-arrays">Max Heap implementation using Arrays</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Heap</span>{</span>
    <span class="hljs-keyword">int</span>* arr;
    <span class="hljs-keyword">int</span> last, <span class="hljs-built_in">size</span>;
};

<span class="hljs-function">struct Heap* <span class="hljs-title">createHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Heap</span> *<span class="hljs-title">heap</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Heap</span>*) <span class="hljs-title">malloc</span> (<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Heap</span>));</span>
    heap-&gt;arr = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">calloc</span> (<span class="hljs-built_in">size</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    heap-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-built_in">size</span>;
    heap-&gt;last = <span class="hljs-number">-1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">index_check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> num)</span></span>{
    <span class="hljs-keyword">if</span> ((index &gt;= <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, num) - <span class="hljs-number">1</span>) || (index &lt; <span class="hljs-number">0</span>))
    {
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_child</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * index) + <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right_child</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-number">2</span> * index) + <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">return</span> (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">percolate_up</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> index)</span></span>{
    <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>)
    {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (arr[parent(index)] &lt; arr[index])
    {
        <span class="hljs-keyword">int</span> temp = arr[parent(index)];
        arr[parent(index)] = arr[index];
        arr[index] = temp;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span>;
    }    
    percolate_up(arr, parent(index));
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">percolate_down</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> last)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt; last){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (arr[index] &gt; arr[left_child(index)] &amp;&amp; arr[index] &gt; arr[right_child(index)])
    {
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span> (arr[left_child(index)] &gt; arr[right_child(index)])
    {
        <span class="hljs-comment">// left child is smaller</span>
        <span class="hljs-keyword">if</span> (arr[index] &lt; arr[left_child(index)])
        {
            <span class="hljs-keyword">int</span> temp = arr[index];
            arr[index] = arr[left_child(index)];
            arr[left_child(index)] = temp;
            percolate_down(arr, left_child(index), last);
        }
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (arr[index] &lt; arr[right_child(index)])
        {
            <span class="hljs-keyword">int</span> temp = arr[index];
            arr[index] = arr[right_child(index)];
            arr[right_child(index)] = temp;
            percolate_down(arr, right_child(index), last);
        }
    }
    
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(struct Heap *h, <span class="hljs-keyword">int</span> val)</span> </span>{
    <span class="hljs-keyword">if</span> (h-&gt;last + <span class="hljs-number">1</span> &gt;= h-&gt;<span class="hljs-built_in">size</span>) {
        h-&gt;<span class="hljs-built_in">size</span>++;
        h-&gt;arr = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">realloc</span>(h-&gt;arr, h-&gt;<span class="hljs-built_in">size</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = h-&gt;last + <span class="hljs-number">1</span>; i &lt; h-&gt;<span class="hljs-built_in">size</span>; ++i) {
            h-&gt;arr[i] = <span class="hljs-number">0</span>;  
        }
    }
    h-&gt;last++;
    h-&gt;arr[h-&gt;last] = val;
    percolate_up(h-&gt;arr, h-&gt;last);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delete_max</span><span class="hljs-params">(struct Heap *h)</span></span>{
    h-&gt;arr[<span class="hljs-number">0</span>] = h-&gt;arr[h-&gt;last];
    <span class="hljs-comment">// h-&gt;arr[h-&gt;last] = 0;</span>
    h-&gt;last--;
    h-&gt;<span class="hljs-built_in">size</span>--;
    percolate_down(h-&gt;arr, <span class="hljs-number">0</span>, h-&gt;last);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display_tree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *tree, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">int</span> level)</span></span>{
    <span class="hljs-keyword">if</span>(index &gt; <span class="hljs-built_in">size</span>){
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-keyword">if</span>(tree[index] == <span class="hljs-number">0</span>){
        <span class="hljs-keyword">return</span>;
    }
    
    display_tree(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>, <span class="hljs-built_in">size</span>, level + <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; level; i++){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|\t"</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"|------&gt;%d\n"</span>, tree[index]);
    display_tree(tree, <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>, <span class="hljs-built_in">size</span>, level + <span class="hljs-number">1</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> n, data;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter number of elements: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;n);
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Heap</span> *<span class="hljs-title">heap</span> = <span class="hljs-title">createHeap</span>(<span class="hljs-title">n</span>);</span>
    heap-&gt;<span class="hljs-built_in">size</span> = n;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter data: "</span>);
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;data);
        insert(heap, data);
    }
    display_tree(heap-&gt;arr, <span class="hljs-number">0</span>, heap-&gt;<span class="hljs-built_in">size</span>, <span class="hljs-number">0</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"____________________________________\n\n"</span>);
    delete_max(heap);
    display_tree(heap-&gt;arr, <span class="hljs-number">0</span>, heap-&gt;<span class="hljs-built_in">size</span>, <span class="hljs-number">0</span>);
}
</div></code></pre>
<hr>
<h3 id="heap-sort-implementation-using-arrays">Heap Sort implementation using Arrays</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heapify</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>, <span class="hljs-keyword">int</span> root)</span></span>{
    <span class="hljs-keyword">int</span> largest = root;
    <span class="hljs-keyword">int</span> left = left_child(root);
    <span class="hljs-keyword">int</span> right = right_child(root);

    <span class="hljs-keyword">if</span>(left &lt; <span class="hljs-built_in">size</span> &amp;&amp; arr[left] &gt; arr[largest]){
        largest = left;
    }

    <span class="hljs-keyword">if</span>(right &lt; <span class="hljs-built_in">size</span> &amp;&amp; arr[right] &gt; arr[largest]){
        largest = right;
    }

    <span class="hljs-keyword">if</span>(largest != root){
        <span class="hljs-keyword">int</span> temp = arr[root];
        arr[root] = arr[largest];
        arr[largest] = temp;
        heapify(arr, <span class="hljs-built_in">size</span>, largest);
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">size</span> / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){
        heapify(arr, <span class="hljs-built_in">size</span>, i);
    }

    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--){
        <span class="hljs-keyword">int</span> temp = arr[<span class="hljs-number">0</span>];
        arr[<span class="hljs-number">0</span>] = arr[i];
        arr[i] = temp;
        heapify(arr, i, <span class="hljs-number">0</span>);
    }
}
</div></code></pre>
<hr>
<h2 id="graphs">Graphs</h2>
<h3 id="graph-implementation-using-adjacency-matrix">Graph implementation using Adjacency Matrix</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span>{</span>
    <span class="hljs-keyword">int</span> **adj;
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;
};

<span class="hljs-function">struct Graph* <span class="hljs-title">createGraph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-built_in">size</span>++;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> *<span class="hljs-title">graph</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Graph</span>*) <span class="hljs-title">malloc</span> (<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Graph</span>));</span>
    graph-&gt;adj = (<span class="hljs-keyword">int</span> **) <span class="hljs-built_in">calloc</span> (<span class="hljs-built_in">size</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span> *));
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; i++)
    {
        graph-&gt;adj[i] = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">calloc</span> (<span class="hljs-built_in">size</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    }
    graph-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-built_in">size</span>;
    <span class="hljs-keyword">return</span> graph;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(struct Graph *graph, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> dest)</span></span>{
    graph-&gt;adj[src][dest] = <span class="hljs-number">1</span>;
    graph-&gt;adj[dest][src] = <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addDirectedEdge</span><span class="hljs-params">(struct Graph *graph, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> dest)</span></span>{
    graph-&gt;adj[src][dest] = <span class="hljs-number">1</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printGraph</span><span class="hljs-params">(struct Graph *graph)</span></span>{
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"  "</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; graph-&gt;<span class="hljs-built_in">size</span>; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, i);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; graph-&gt;<span class="hljs-built_in">size</span>; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, i);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; graph-&gt;<span class="hljs-built_in">size</span>; j++)
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, graph-&gt;adj[i][j]);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildGraph</span><span class="hljs-params">(struct Graph *graph)</span></span>{
    <span class="hljs-keyword">int</span> src, dest;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter the source and destination vertices (-1 -1 to exit): "</span>);
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;src, &amp;dest);
        <span class="hljs-keyword">if</span> (src == <span class="hljs-number">-1</span> &amp;&amp; dest == <span class="hljs-number">-1</span>)
        {
            <span class="hljs-keyword">break</span>;
        }
        addDirectedEdge(graph, src, dest);
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(struct Graph *graph, <span class="hljs-keyword">int</span> src)</span></span>{
    <span class="hljs-keyword">int</span> *<span class="hljs-built_in">stack</span> = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span> (graph-&gt;<span class="hljs-built_in">size</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">int</span> *visited = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">calloc</span> (graph-&gt;<span class="hljs-built_in">size</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-built_in">stack</span>[++top] = src;
    visited[src] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (top != <span class="hljs-number">-1</span>)
    {
        <span class="hljs-keyword">int</span> curr = <span class="hljs-built_in">stack</span>[top--];
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, curr);
        visited[curr] = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; graph-&gt;<span class="hljs-built_in">size</span>; i++)
        {
            <span class="hljs-keyword">if</span> (graph-&gt;adj[curr][i] == <span class="hljs-number">1</span> &amp;&amp; visited[i] == <span class="hljs-number">0</span>)
            {
                <span class="hljs-built_in">stack</span>[++top] = i;
                visited[i] = <span class="hljs-number">1</span>;
            }
        }
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(struct Graph *graph, <span class="hljs-keyword">int</span> src)</span></span>{
    <span class="hljs-keyword">int</span> *<span class="hljs-built_in">queue</span> = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span> (graph-&gt;<span class="hljs-built_in">size</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-keyword">int</span> front = <span class="hljs-number">-1</span>, rear = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">int</span> *visited = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">calloc</span> (graph-&gt;<span class="hljs-built_in">size</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-built_in">queue</span>[++rear] = src;
    front++;
    visited[src] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (front != rear)
    {
        <span class="hljs-keyword">int</span> curr = <span class="hljs-built_in">queue</span>[++front];
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, curr);
        visited[curr] = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; graph-&gt;<span class="hljs-built_in">size</span>; i++)
        {
            <span class="hljs-keyword">if</span> (graph-&gt;adj[curr][i] == <span class="hljs-number">1</span> &amp;&amp; visited[i] == <span class="hljs-number">0</span>)
            {
                <span class="hljs-built_in">queue</span>[++rear] = i;
                visited[i] = <span class="hljs-number">1</span>;
            }
        }
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter the number of vertices: "</span>);
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>, &amp;<span class="hljs-built_in">size</span>);
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> *<span class="hljs-title">graph</span> = <span class="hljs-title">createGraph</span>(<span class="hljs-title">size</span>);</span>
    buildGraph(graph);
    printGraph(graph);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"DFS: "</span>);
    dfs(graph, <span class="hljs-number">1</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"BFS: "</span>);
    bfs(graph, <span class="hljs-number">1</span>);
}
</div></code></pre>
<h3 id="graph-implementation-using-adjacency-list">Graph implementation using Adjacency List</h3>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span>
    <span class="hljs-keyword">int</span> data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span>
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span>{</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> **<span class="hljs-title">adj</span>;</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>;
};

<span class="hljs-function">struct Graph* <span class="hljs-title">createGraph</span><span class="hljs-params">(<span class="hljs-keyword">int</span> <span class="hljs-built_in">size</span>)</span></span>{
    <span class="hljs-built_in">size</span>++;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> *<span class="hljs-title">graph</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Graph</span>*) <span class="hljs-title">malloc</span> (<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Graph</span>));</span>
    graph-&gt;adj = (struct Node **) <span class="hljs-built_in">calloc</span> (<span class="hljs-built_in">size</span>, <span class="hljs-keyword">sizeof</span>(struct Node *));
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span>; i++)
    {
        graph-&gt;adj[i] = <span class="hljs-literal">NULL</span>;
    }
    graph-&gt;<span class="hljs-built_in">size</span> = <span class="hljs-built_in">size</span>;
    <span class="hljs-keyword">return</span> graph;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(struct Graph *graph, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> dest)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Node</span> *) <span class="hljs-title">malloc</span> (<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>));</span>
    newNode-&gt;data = dest;
    newNode-&gt;next = graph-&gt;adj[src];
    graph-&gt;adj[src] = newNode;

    newNode = (struct Node *) <span class="hljs-built_in">malloc</span> (<span class="hljs-keyword">sizeof</span>(struct Node));
    newNode-&gt;data = src;
    newNode-&gt;next = graph-&gt;adj[dest];
    graph-&gt;adj[dest] = newNode;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addDirectedEdge</span><span class="hljs-params">(struct Graph *graph, <span class="hljs-keyword">int</span> src, <span class="hljs-keyword">int</span> dest)</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">newNode</span> = (<span class="hljs-title">struct</span> <span class="hljs-title">Node</span> *) <span class="hljs-title">malloc</span> (<span class="hljs-title">sizeof</span>(<span class="hljs-title">struct</span> <span class="hljs-title">Node</span>));</span>
    newNode-&gt;data = dest;
    newNode-&gt;next = graph-&gt;adj[src];
    graph-&gt;adj[src] = newNode;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printGraph</span><span class="hljs-params">(struct Graph *graph)</span></span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; graph-&gt;<span class="hljs-built_in">size</span>; i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d: "</span>, i);
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> = <span class="hljs-title">graph</span>-&gt;<span class="hljs-title">adj</span>[<span class="hljs-title">i</span>];</span>
        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span>)
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, temp-&gt;data);
            temp = temp-&gt;next;
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildGraph</span><span class="hljs-params">(struct Graph *graph)</span></span>{
    <span class="hljs-keyword">int</span> src, dest;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Enter the source and destination vertices (-1 -1 to exit): "</span>);
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d %d"</span>, &amp;src, &amp;dest);
        <span class="hljs-keyword">if</span> (src == <span class="hljs-number">-1</span> &amp;&amp; dest == <span class="hljs-number">-1</span>)
        {
            <span class="hljs-keyword">break</span>;
        }
        addDirectedEdge(graph, src, dest);
    }
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(struct Graph *graph, <span class="hljs-keyword">int</span> src)</span></span>{
    <span class="hljs-keyword">int</span> *<span class="hljs-built_in">stack</span> = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span> (graph-&gt;<span class="hljs-built_in">size</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-keyword">int</span> top = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">int</span> *visited = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">calloc</span> (graph-&gt;<span class="hljs-built_in">size</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-built_in">stack</span>[++top] = src;
    visited[src] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (top != <span class="hljs-number">-1</span>)
    {
        <span class="hljs-keyword">int</span> curr = <span class="hljs-built_in">stack</span>[top--];
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, curr);
        visited[curr] = <span class="hljs-number">2</span>;
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> = <span class="hljs-title">graph</span>-&gt;<span class="hljs-title">adj</span>[<span class="hljs-title">curr</span>];</span>
        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span>)
        {
            <span class="hljs-keyword">if</span> (visited[temp-&gt;data] == <span class="hljs-number">0</span>)
            {
                <span class="hljs-built_in">stack</span>[++top] = temp-&gt;data;
                visited[temp-&gt;data] = <span class="hljs-number">1</span>;
            }
            temp = temp-&gt;next;
        }
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(struct Graph *graph, <span class="hljs-keyword">int</span> src)</span></span>{
    <span class="hljs-keyword">int</span> *<span class="hljs-built_in">queue</span> = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span> (graph-&gt;<span class="hljs-built_in">size</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-keyword">int</span> front = <span class="hljs-number">-1</span>, rear = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">int</span> *visited = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">calloc</span> (graph-&gt;<span class="hljs-built_in">size</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-built_in">queue</span>[++rear] = src;
    front++;
    visited[src] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span> (front != rear)
    {
        <span class="hljs-keyword">int</span> curr = <span class="hljs-built_in">queue</span>[++front];
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, curr);
        visited[curr] = <span class="hljs-number">2</span>;
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">temp</span> = <span class="hljs-title">graph</span>-&gt;<span class="hljs-title">adj</span>[<span class="hljs-title">curr</span>];</span>
        <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">NULL</span>)
        {
            <span class="hljs-keyword">if</span> (visited[temp-&gt;data] == <span class="hljs-number">0</span>)
            {
                <span class="hljs-built_in">queue</span>[++rear] = temp-&gt;data;
                visited[temp-&gt;data] = <span class="hljs-number">1</span>;
            }
            temp = temp-&gt;next;
        }
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}                       
</div></code></pre>
<hr>
<h3 id="topological-sort-implementation-using-adjacency-matrix">Topological Sort implementation using Adjacency Matrix</h3>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">indegree</span><span class="hljs-params">(struct Graph *graph, <span class="hljs-keyword">int</span> vertex)</span></span>{
    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; graph-&gt;<span class="hljs-built_in">size</span>; i++)
    {
        <span class="hljs-keyword">if</span> (graph-&gt;adj[i][vertex] == <span class="hljs-number">1</span>)
        {
            count++;
        }
    }
    <span class="hljs-keyword">return</span> count;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">topological_sort</span><span class="hljs-params">(struct Graph *graph)</span></span>{
    <span class="hljs-keyword">int</span> *<span class="hljs-built_in">queue</span> = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">malloc</span> (graph-&gt;<span class="hljs-built_in">size</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-keyword">int</span> front = <span class="hljs-number">-1</span>, rear = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">int</span> *visited = (<span class="hljs-keyword">int</span> *) <span class="hljs-built_in">calloc</span> (graph-&gt;<span class="hljs-built_in">size</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; graph-&gt;<span class="hljs-built_in">size</span>; i++)
    {
        <span class="hljs-keyword">if</span> (indegree(graph, i) == <span class="hljs-number">0</span>)
        {
            <span class="hljs-built_in">queue</span>[++rear] = i;
            front++;
            visited[i] = <span class="hljs-number">1</span>;
        }
    }
    <span class="hljs-keyword">while</span> (front != rear)
    {
        <span class="hljs-keyword">int</span> curr = <span class="hljs-built_in">queue</span>[++front];
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, curr);
        visited[curr] = <span class="hljs-number">2</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; graph-&gt;<span class="hljs-built_in">size</span>; i++)
        {
            <span class="hljs-keyword">if</span> (graph-&gt;adj[curr][i] == <span class="hljs-number">1</span> &amp;&amp; visited[i] == <span class="hljs-number">0</span>)
            {
                <span class="hljs-built_in">queue</span>[++rear] = i;
                visited[i] = <span class="hljs-number">1</span>;
            }
        }
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}
</div></code></pre>

</body>

</html>